From 35b5127b0fc0d595c552b8531a1f64fa0f132c06 Mon Sep 17 00:00:00 2001
From: YangKunlun <yangkunlun@gmail.com>
Date: Fri, 30 Oct 2015 07:49:17 +0800
Subject: [PATCH 1/2] Fixed the ethernet driver

---
 arch/arm/mach-cns3xxx/cns3420vb.c                 |  40 ++++++
 drivers/net/ethernet/cavium/Kconfig               |  18 ++-
 drivers/net/ethernet/cavium/Makefile              |   1 +
 drivers/net/ethernet/cavium/cns3xxx/cns3xxx_eth.c | 146 +++++++++++-----------
 4 files changed, 128 insertions(+), 77 deletions(-)

diff --git a/arch/arm/mach-cns3xxx/cns3420vb.c b/arch/arm/mach-cns3xxx/cns3420vb.c
index 6428bcc..81307db 100644
--- a/arch/arm/mach-cns3xxx/cns3420vb.c
+++ b/arch/arm/mach-cns3xxx/cns3420vb.c
@@ -31,6 +31,7 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
+#include <linux/platform_data/cns3xxx.h>
 #include "cns3xxx.h"
 #include "pm.h"
 #include "core.h"
@@ -207,12 +208,51 @@ static struct platform_device cns3xxx_usb_ohci_device = {
 };
 
 /*
+ * Ethernet
+ */
+static struct cns3xxx_plat_info laguna_net_data = {
+	.ports = 0x01,
+	.phy = {
+		0,
+		1,
+		2,
+	},
+};
+
+static struct resource laguna_net_resource[] = {
+	{
+		.name = "eth0_mem",
+		.start = CNS3XXX_SWITCH_BASE,
+		.end = CNS3XXX_SWITCH_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM
+	}, {
+		.name = "eth_rx",
+		.start = IRQ_CNS3XXX_SW_R0RXC,
+		.end = IRQ_CNS3XXX_SW_R0RXC,
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+static u64 laguna_net_dmamask = DMA_BIT_MASK(32);
+static struct platform_device laguna_net_device = {
+	.name = "cns3xxx_eth",
+	.num_resources = ARRAY_SIZE(laguna_net_resource),
+	.resource = laguna_net_resource,
+	.dev = {
+		.dma_mask = &laguna_net_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &laguna_net_data,
+	}
+};
+
+/*
  * Initialization
  */
 static struct platform_device *cns3420_pdevs[] __initdata = {
 	&cns3420_nor_pdev,
 	&cns3xxx_usb_ehci_device,
 	&cns3xxx_usb_ohci_device,
+    &laguna_net_device,
 };
 
 static void __init cns3420_init(void)
diff --git a/drivers/net/ethernet/cavium/Kconfig b/drivers/net/ethernet/cavium/Kconfig
index 02e23e6..258f0ca 100644
--- a/drivers/net/ethernet/cavium/Kconfig
+++ b/drivers/net/ethernet/cavium/Kconfig
@@ -4,7 +4,7 @@
 
 config NET_VENDOR_CAVIUM
 	tristate "Cavium ethernet drivers"
-	depends on PCI
+	depends on PCI || ARCH_CNS3XXX
 	default y
 	---help---
 	  Select this option if you want enable Cavium network support.
@@ -13,9 +13,17 @@ config NET_VENDOR_CAVIUM
 
 if NET_VENDOR_CAVIUM
 
+config CNS3XXX_ETH
+	tristate "Cavium CNS3xxx Ethernet support"
+	depends on ARCH_CNS3XXX
+	select PHYLIB
+	help
+	  Say Y here if you want to use built-in Ethernet ports
+	  on CNS3XXX processor.
+
 config THUNDER_NIC_PF
 	tristate "Thunder Physical function driver"
-	depends on 64BIT
+	depends on 64BIT && PCI
 	select THUNDER_NIC_BGX
 	---help---
 	  This driver supports Thunder's NIC physical function.
@@ -27,20 +35,20 @@ config THUNDER_NIC_PF
 
 config THUNDER_NIC_VF
 	tristate "Thunder Virtual function driver"
-	depends on 64BIT
+	depends on 64BIT && PCI
 	---help---
 	  This driver supports Thunder's NIC virtual function
 
 config	THUNDER_NIC_BGX
 	tristate "Thunder MAC interface driver (BGX)"
-	depends on 64BIT
+	depends on 64BIT && PCI
 	---help---
 	  This driver supports programming and controlling of MAC
 	  interface from NIC physical function driver.
 
 config LIQUIDIO
 	tristate "Cavium LiquidIO support"
-	depends on 64BIT
+	depends on 64BIT && PCI
 	select PTP_1588_CLOCK
 	select FW_LOADER
 	select LIBCRC32C
diff --git a/drivers/net/ethernet/cavium/Makefile b/drivers/net/ethernet/cavium/Makefile
index d22f886..1bef114 100644
--- a/drivers/net/ethernet/cavium/Makefile
+++ b/drivers/net/ethernet/cavium/Makefile
@@ -3,3 +3,4 @@
 #
 obj-$(CONFIG_NET_VENDOR_CAVIUM) += thunder/
 obj-$(CONFIG_NET_VENDOR_CAVIUM) += liquidio/
+obj-$(CONFIG_NET_VENDOR_CAVIUM) += cns3xxx/
diff --git a/drivers/net/ethernet/cavium/cns3xxx/cns3xxx_eth.c b/drivers/net/ethernet/cavium/cns3xxx/cns3xxx_eth.c
index e2db636..89ba649 100644
--- a/drivers/net/ethernet/cavium/cns3xxx/cns3xxx_eth.c
+++ b/drivers/net/ethernet/cavium/cns3xxx/cns3xxx_eth.c
@@ -56,7 +56,6 @@
 #define FIRST_SEGMENT 0x20000000
 #define LAST_SEGMENT 0x10000000
 #define FORCE_ROUTE 0x04000000
-#define IP_CHECKSUM 0x00040000
 #define UDP_CHECKSUM 0x00020000
 #define TCP_CHECKSUM 0x00010000
 
@@ -96,6 +95,19 @@
 #define MAC1_RX_ERROR 0x00200000
 #define MAC2_RX_ERROR 0x00400000
 
+/* MAC Clock - Seagate Central u-boot */
+#define MAC0_CLOCK_ENABLE   (1<<7)
+#define MAC1_CLOCK_ENABLE   (1<<15)
+#define MAC2_CLOCK_ENABLE   (1<<23)
+
+#define GMII_CLOCK_SKEW     0x00000050
+#define MAC_SPEED_1000          2
+#define MAC_SPEED_100           1
+#define MAC_SPEED_10            0
+
+#define MAC_DUPLEX_FULL         1
+#define MAC_DUPLEX_HALF         0
+
 struct tx_desc
 {
 	u32 sdp; /* segment data pointer */
@@ -290,7 +302,6 @@ struct sw {
 	struct sk_buff *frag_last;
 	struct device *dev;
 	int rx_irq;
-	int stat_irq;
 };
 
 struct port {
@@ -418,6 +429,8 @@ static void cns3xxx_adjust_link(struct net_device *dev)
 {
 	struct port *port = netdev_priv(dev);
 	struct phy_device *phydev = port->phydev;
+    struct sw * sw = port->sw;
+    u32 mac_cfg_new;
 
 	if (!phydev->link) {
 		if (port->speed) {
@@ -433,6 +446,19 @@ static void cns3xxx_adjust_link(struct net_device *dev)
 	port->speed = phydev->speed;
 	port->duplex = phydev->duplex;
 
+    //decode this part from u-boot source code!
+    mac_cfg_new = __raw_readl(&sw->regs->mac_cfg[port->id]);
+    mac_cfg_new &= (~(3 << 8));
+    if(port->speed == 1000)
+        mac_cfg_new |= (MAC_SPEED_1000 << 8);
+    else if(port->speed == 100)
+        mac_cfg_new |= (MAC_SPEED_100 << 8);
+
+    mac_cfg_new &= (~(1 << 10));
+    if(port->duplex)
+        mac_cfg_new |= (1<<10);
+    __raw_writel(mac_cfg_new, &sw->regs->mac_cfg[port->id]);
+
 	printk(KERN_INFO "%s: link up, speed %u Mb/s, %s duplex\n",
 	       dev->name, port->speed, port->duplex ? "full" : "half");
 }
@@ -454,64 +480,6 @@ irqreturn_t eth_rx_irq(int irq, void *pdev)
 	return (IRQ_HANDLED);
 }
 
-irqreturn_t eth_stat_irq(int irq, void *pdev)
-{
-	struct net_device *dev = pdev;
-	struct sw *sw = netdev_priv(dev);
-	u32 cfg;
-	u32 stat = __raw_readl(&sw->regs->intr_stat);
-	__raw_writel(0xffffffff, &sw->regs->intr_stat);
-
-	if (stat & MAC2_RX_ERROR)
-		switch_port_tab[3]->netdev->stats.rx_dropped++;
-	if (stat & MAC1_RX_ERROR)
-		switch_port_tab[1]->netdev->stats.rx_dropped++;
-	if (stat & MAC0_RX_ERROR)
-		switch_port_tab[0]->netdev->stats.rx_dropped++;
-
-	if (stat & MAC0_STATUS_CHANGE) {
-		cfg = __raw_readl(&sw->regs->mac_cfg[0]);
-		switch_port_tab[0]->phydev->link = (cfg & 0x1);
-		switch_port_tab[0]->phydev->duplex = ((cfg >> 4) & 0x1);
-		if (((cfg >> 2) & 0x3) == 2)
-			switch_port_tab[0]->phydev->speed = 1000;
-		else if (((cfg >> 2) & 0x3) == 1)
-			switch_port_tab[0]->phydev->speed = 100;
-		else
-			switch_port_tab[0]->phydev->speed = 10;
-		cns3xxx_adjust_link(switch_port_tab[0]->netdev);
-	}
-
-	if (stat & MAC1_STATUS_CHANGE) {
-		cfg = __raw_readl(&sw->regs->mac_cfg[1]);
-		switch_port_tab[1]->phydev->link = (cfg & 0x1);
-		switch_port_tab[1]->phydev->duplex = ((cfg >> 4) & 0x1);
-		if (((cfg >> 2) & 0x3) == 2)
-			switch_port_tab[1]->phydev->speed = 1000;
-		else if (((cfg >> 2) & 0x3) == 1)
-			switch_port_tab[1]->phydev->speed = 100;
-		else
-			switch_port_tab[1]->phydev->speed = 10;
-		cns3xxx_adjust_link(switch_port_tab[1]->netdev);
-	}
-
-	if (stat & MAC2_STATUS_CHANGE) {
-		cfg = __raw_readl(&sw->regs->mac_cfg[3]);
-		switch_port_tab[3]->phydev->link = (cfg & 0x1);
-		switch_port_tab[3]->phydev->duplex = ((cfg >> 4) & 0x1);
-		if (((cfg >> 2) & 0x3) == 2)
-			switch_port_tab[3]->phydev->speed = 1000;
-		else if (((cfg >> 2) & 0x3) == 1)
-			switch_port_tab[3]->phydev->speed = 100;
-		else
-			switch_port_tab[3]->phydev->speed = 10;
-		cns3xxx_adjust_link(switch_port_tab[3]->netdev);
-	}
-
-	return (IRQ_HANDLED);
-}
-
-
 static void cns3xxx_alloc_rx_buf(struct sw *sw, int received)
 {
 	struct _rx_ring *rx_ring = &sw->rx_ring;
@@ -714,15 +682,13 @@ static int eth_poll(struct napi_struct *napi, int budget)
 		}
 	}
 
-	rx_ring->cur_index = i;
-	if (!received) {
-		napi_complete(napi);
-		enable_irq(sw->rx_irq);
+    rx_ring->cur_index = i;
+    enable_irq(sw->rx_irq);
+    napi_complete(napi);
 
-		/* if rx descriptors are full schedule another poll */
-		if (rx_ring->desc[(i-1) & (RX_DESCS-1)].cown)
-			eth_schedule_poll(sw);
-	}
+    /* if rx descriptors are full schedule another poll */
+    if (rx_ring->desc[(i-1) & (RX_DESCS-1)].cown)
+        eth_schedule_poll(sw);
 
 	spin_lock_bh(&tx_lock);
 	eth_complete_tx(sw);
@@ -997,6 +963,17 @@ static void destroy_rings(struct sw *sw)
 	}
 }
 
+static void cns3xxx_print_switch_reg(const char *msg, u32 *xxx)
+{
+    int i;
+    printk(KERN_INFO "%s:\n", msg);
+    for(i=0; i<offsetof(struct switch_regs, fs_desc_base_addr1)/4; i=i+8) {
+		printk(KERN_INFO "%04d: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",
+                i, xxx[i+0], xxx[i+1], xxx[i+2], xxx[i+3], 
+                xxx[i+4], xxx[i+5], xxx[i+6], xxx[i+7]);
+    }
+}
+
 static int eth_open(struct net_device *dev)
 {
 	struct port *port = netdev_priv(dev);
@@ -1010,7 +987,6 @@ static int eth_open(struct net_device *dev)
 
 	if (!ports_open) {
 		request_irq(sw->rx_irq, eth_rx_irq, IRQF_SHARED, "gig_switch", napi_dev);
-		request_irq(sw->stat_irq, eth_stat_irq, IRQF_SHARED, "gig_stat", napi_dev);
 		napi_enable(&sw->napi);
 		netif_start_queue(napi_dev);
 
@@ -1034,6 +1010,31 @@ static int eth_open(struct net_device *dev)
 	ports_open++;
 	netif_carrier_on(dev);
 
+    cns3xxx_print_switch_reg("eth_open switch register before fix", (u32*)sw->regs);
+
+    //////////////////////////////////
+    temp = GMII_CLOCK_SKEW;
+	__raw_writel(temp, &sw->regs->clk_skew_ctrl);
+
+    temp = __raw_readl(&sw->regs->phy_auto_addr);
+    temp |= MAC0_CLOCK_ENABLE;
+	__raw_writel(temp, &sw->regs->phy_auto_addr);
+
+    //when detected phy speed change, should change this value
+    //see u-boot cns3xxx_gsw.c - line 237, nasty hack for Seagate Central
+    // <<11 two bit for flow control
+    // <<10 is duplex or half
+    // <<8  two bit for speed
+    // 0-7 is unknown!
+    //temp = __raw_readl(&sw->regs->mac_cfg[0]);
+    //temp &= 0xFFFFF000; //the last 12 bits miss configured
+    //temp |= (0x005bbe79 & 0x00000FFF);
+    //temp &= 0xFFFFFF00; //the last 8 bits mis-configured, we don't know yet!
+    //temp |= (0x005bbe79 & 0x000000FF);  //this still work!
+	//__raw_writel(temp, &sw->regs->mac_cfg[0]);
+
+    cns3xxx_print_switch_reg("eth_open switch register after fix", (u32*)sw->regs);
+
 	return 0;
 }
 
@@ -1056,8 +1057,6 @@ static int eth_close(struct net_device *dev)
 	if (!ports_open) {
 		disable_irq(sw->rx_irq);
 		free_irq(sw->rx_irq, napi_dev);
-		disable_irq(sw->stat_irq);
-		free_irq(sw->stat_irq, napi_dev);
 		napi_disable(&sw->napi);
 		netif_stop_queue(napi_dev);
 		temp = __raw_readl(&sw->regs->mac_cfg[2]);
@@ -1203,8 +1202,9 @@ static int eth_init_one(struct platform_device *pdev)
 	sw->regs = regs;
 	sw->dev = &pdev->dev;
 
+    cns3xxx_print_switch_reg("eth_init_one switch register left by u-boot:", (u32*)regs);
+
 	sw->rx_irq = platform_get_irq_byname(pdev, "eth_rx");
-	sw->stat_irq = platform_get_irq_byname(pdev, "eth_stat");
 
 	temp = __raw_readl(&sw->regs->phy_auto_addr);
 	temp |= (3 << 30); /* maximum frame length: 9600 bytes */
@@ -1242,6 +1242,8 @@ static int eth_init_one(struct platform_device *pdev)
 
 		if (!(dev = alloc_etherdev(sizeof(struct port)))) {
 			goto free_ports;
+            //TODO: here we should initiate whatever ports we can
+            //only skip those failed, instead of failall!!!
 		}
 
 		port = netdev_priv(dev);
-- 
2.1.4


From 90e654f124f3bcb22cb34fb3fd14c9c31286b1b5 Mon Sep 17 00:00:00 2001
From: YangKunlun <yangkunlun@gmail.com>
Date: Fri, 30 Oct 2015 21:22:12 +0800
Subject: [PATCH 2/2] some cleanup

---
 drivers/net/ethernet/cavium/cns3xxx/cns3xxx_eth.c | 22 +++-------------------
 1 file changed, 3 insertions(+), 19 deletions(-)

diff --git a/drivers/net/ethernet/cavium/cns3xxx/cns3xxx_eth.c b/drivers/net/ethernet/cavium/cns3xxx/cns3xxx_eth.c
index 89ba649..bee0675 100644
--- a/drivers/net/ethernet/cavium/cns3xxx/cns3xxx_eth.c
+++ b/drivers/net/ethernet/cavium/cns3xxx/cns3xxx_eth.c
@@ -1010,9 +1010,8 @@ static int eth_open(struct net_device *dev)
 	ports_open++;
 	netif_carrier_on(dev);
 
-    cns3xxx_print_switch_reg("eth_open switch register before fix", (u32*)sw->regs);
+    cns3xxx_print_switch_reg("eth_open register before fix", (u32*)sw->regs);
 
-    //////////////////////////////////
     temp = GMII_CLOCK_SKEW;
 	__raw_writel(temp, &sw->regs->clk_skew_ctrl);
 
@@ -1020,20 +1019,7 @@ static int eth_open(struct net_device *dev)
     temp |= MAC0_CLOCK_ENABLE;
 	__raw_writel(temp, &sw->regs->phy_auto_addr);
 
-    //when detected phy speed change, should change this value
-    //see u-boot cns3xxx_gsw.c - line 237, nasty hack for Seagate Central
-    // <<11 two bit for flow control
-    // <<10 is duplex or half
-    // <<8  two bit for speed
-    // 0-7 is unknown!
-    //temp = __raw_readl(&sw->regs->mac_cfg[0]);
-    //temp &= 0xFFFFF000; //the last 12 bits miss configured
-    //temp |= (0x005bbe79 & 0x00000FFF);
-    //temp &= 0xFFFFFF00; //the last 8 bits mis-configured, we don't know yet!
-    //temp |= (0x005bbe79 & 0x000000FF);  //this still work!
-	//__raw_writel(temp, &sw->regs->mac_cfg[0]);
-
-    cns3xxx_print_switch_reg("eth_open switch register after fix", (u32*)sw->regs);
+    cns3xxx_print_switch_reg("eth_open register after fix", (u32*)sw->regs);
 
 	return 0;
 }
@@ -1202,7 +1188,7 @@ static int eth_init_one(struct platform_device *pdev)
 	sw->regs = regs;
 	sw->dev = &pdev->dev;
 
-    cns3xxx_print_switch_reg("eth_init_one switch register left by u-boot:", (u32*)regs);
+    cns3xxx_print_switch_reg("eth_init_one register left by u-boot:", (u32*)regs);
 
 	sw->rx_irq = platform_get_irq_byname(pdev, "eth_rx");
 
@@ -1242,8 +1228,6 @@ static int eth_init_one(struct platform_device *pdev)
 
 		if (!(dev = alloc_etherdev(sizeof(struct port)))) {
 			goto free_ports;
-            //TODO: here we should initiate whatever ports we can
-            //only skip those failed, instead of failall!!!
 		}
 
 		port = netdev_priv(dev);
-- 
2.1.4

