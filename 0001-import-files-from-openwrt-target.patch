From 9ebc299e1a4704781853449af6b93cc665bdbd9a Mon Sep 17 00:00:00 2001
From: root <root@seagate-dev.WeTube>
Date: Fri, 14 Jul 2017 13:54:06 +0000
Subject: [PATCH 1/2] add openwrt files

---
 arch/arm/mach-cns3xxx/cns3xxx_fiq.S       |   87 ++
 arch/arm/mach-cns3xxx/gpio.c              |  292 +++++++
 arch/arm/mach-cns3xxx/headsmp.S           |   41 +
 arch/arm/mach-cns3xxx/hotplug.c           |  130 +++
 arch/arm/mach-cns3xxx/include/mach/gpio.h |   17 +
 arch/arm/mach-cns3xxx/include/mach/smp.h  |    8 +
 arch/arm/mach-cns3xxx/laguna.c            | 1081 +++++++++++++++++++++++
 arch/arm/mach-cns3xxx/platsmp.c           |  327 +++++++
 drivers/i2c/busses/i2c-cns3xxx.c          |  374 ++++++++
 drivers/net/ethernet/cavium/Kconfig       |   62 +-
 drivers/net/ethernet/cavium/Makefile      |    4 +-
 drivers/net/ethernet/cavium/cns3xxx_eth.c | 1340 +++++++++++++++++++++++++++++
 drivers/spi/spi-cns3xxx.c                 |  448 ++++++++++
 include/linux/platform_data/cns3xxx.h     |   26 +
 14 files changed, 4188 insertions(+), 49 deletions(-)
 create mode 100644 arch/arm/mach-cns3xxx/cns3xxx_fiq.S
 create mode 100644 arch/arm/mach-cns3xxx/gpio.c
 create mode 100644 arch/arm/mach-cns3xxx/headsmp.S
 create mode 100644 arch/arm/mach-cns3xxx/hotplug.c
 create mode 100644 arch/arm/mach-cns3xxx/include/mach/gpio.h
 create mode 100644 arch/arm/mach-cns3xxx/include/mach/smp.h
 create mode 100644 arch/arm/mach-cns3xxx/laguna.c
 create mode 100644 arch/arm/mach-cns3xxx/platsmp.c
 create mode 100644 drivers/i2c/busses/i2c-cns3xxx.c
 create mode 100644 drivers/net/ethernet/cavium/cns3xxx_eth.c
 create mode 100644 drivers/spi/spi-cns3xxx.c
 create mode 100644 include/linux/platform_data/cns3xxx.h

diff --git a/arch/arm/mach-cns3xxx/cns3xxx_fiq.S b/arch/arm/mach-cns3xxx/cns3xxx_fiq.S
new file mode 100644
index 00000000..b1155ef5
--- /dev/null
+++ b/arch/arm/mach-cns3xxx/cns3xxx_fiq.S
@@ -0,0 +1,87 @@
+/*
+ *  Copyright (C) 2012 Gateworks Corporation
+ *      Chris Lang <clang@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/asm-offsets.h>
+
+#define D_CACHE_LINE_SIZE 32
+
+	.text
+
+/*
+ * R8  - DMA Start Address
+ * R9  - DMA Length
+ * R10 - DMA Direction
+ * R11 - DMA type
+ * R12 - fiq_buffer Address
+*/
+
+	.global	cns3xxx_fiq_end
+ENTRY(cns3xxx_fiq_start)
+	str	r8, [r13]
+
+	ldmia	r12, {r8, r9, r10}
+	and	r11, r10, #0x3000000
+	and	r10, r10, #0xff
+
+	teq	r11, #0x1000000
+	beq	cns3xxx_dma_map_area
+	teq	r11, #0x2000000
+	beq	cns3xxx_dma_unmap_area
+	/* fall through */
+cns3xxx_dma_flush_range:
+	bic	r8, r8, #D_CACHE_LINE_SIZE - 1
+1:
+	mcr	p15, 0, r8, c7, c14, 1		@ clean & invalidate D line
+	add	r8, r8, #D_CACHE_LINE_SIZE
+	cmp	r8, r9
+	blo	1b
+	/* fall through */
+cns3xxx_fiq_exit:
+	mov	r8, #0
+	str	r8, [r12, #8]
+	mcr	p15, 0, r8, c7, c10, 4		@ drain write buffer
+	subs	pc, lr, #4
+
+cns3xxx_dma_map_area:
+	add	r9, r9, r8
+	teq	r10, #DMA_FROM_DEVICE
+	beq	cns3xxx_dma_inv_range
+	teq	r10, #DMA_TO_DEVICE
+	bne	cns3xxx_dma_flush_range
+	/* fall through */
+cns3xxx_dma_clean_range:
+	bic	r8, r8, #D_CACHE_LINE_SIZE - 1
+1:
+	mcr	p15, 0, r8, c7, c10, 1		@ clean D line
+	add	r8, r8, #D_CACHE_LINE_SIZE
+	cmp	r8, r9
+	blo	1b
+	b	cns3xxx_fiq_exit
+
+cns3xxx_dma_unmap_area:
+	add	r9, r9, r8
+	teq	r10, #DMA_TO_DEVICE
+	beq	cns3xxx_fiq_exit
+	/* fall through */
+cns3xxx_dma_inv_range:
+	tst	r8, #D_CACHE_LINE_SIZE - 1
+	bic	r8, r8, #D_CACHE_LINE_SIZE - 1
+	mcrne	p15, 0, r8, c7, c10, 1		@ clean D line
+	tst	r9, #D_CACHE_LINE_SIZE - 1
+	bic	r9, r9, #D_CACHE_LINE_SIZE - 1
+	mcrne	p15, 0, r9, c7, c14, 1		@ clean & invalidate D line
+1:
+	mcr	p15, 0, r8, c7, c6, 1		@ invalidate D line
+	add	r8, r8, #D_CACHE_LINE_SIZE
+	cmp	r8, r9
+	blo	1b
+	b	cns3xxx_fiq_exit
+
+cns3xxx_fiq_end:
diff --git a/arch/arm/mach-cns3xxx/gpio.c b/arch/arm/mach-cns3xxx/gpio.c
new file mode 100644
index 00000000..19de24c3
--- /dev/null
+++ b/arch/arm/mach-cns3xxx/gpio.c
@@ -0,0 +1,292 @@
+/*
+ * Copyright 2012 Gateworks Corporation
+ *     Chris Lang <clang@gateworks.com>
+ *     Tim Harvey <tharvey@gateworks.com>
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+
+#include <asm/mach/irq.h>
+
+/*
+ * Registers
+ */
+#define GPIO_INPUT                          0x04
+#define GPIO_DIR                            0x08
+#define GPIO_SET                            0x10
+#define GPIO_CLEAR                          0x14
+#define GPIO_INTERRUPT_ENABLE               0x20
+#define GPIO_INTERRUPT_RAW_STATUS           0x24
+#define GPIO_INTERRUPT_MASKED_STATUS        0x28
+#define GPIO_INTERRUPT_MASK                 0x2C
+#define GPIO_INTERRUPT_CLEAR                0x30
+#define GPIO_INTERRUPT_TRIGGER_METHOD       0x34
+#define GPIO_INTERRUPT_TRIGGER_BOTH_EDGES   0x38
+#define GPIO_INTERRUPT_TRIGGER_TYPE         0x3C
+
+#define GPIO_INTERRUPT_TRIGGER_METHOD_EDGE  0
+#define GPIO_INTERRUPT_TRIGGER_METHOD_LEVEL 1
+#define GPIO_INTERRUPT_TRIGGER_EDGE_SINGLE  0
+#define GPIO_INTERRUPT_TRIGGER_EDGE_BOTH    1
+#define GPIO_INTERRUPT_TRIGGER_TYPE_RISING  0
+#define GPIO_INTERRUPT_TRIGGER_TYPE_FALLING 1
+#define GPIO_INTERRUPT_TRIGGER_TYPE_HIGH    0
+#define GPIO_INTERRUPT_TRIGGER_TYPE_LOW     1
+
+struct cns3xxx_gpio_chip {
+	struct gpio_chip    chip;
+	struct irq_domain   *domain;
+	spinlock_t          lock;
+	void __iomem        *base;
+};
+
+static struct cns3xxx_gpio_chip cns3xxx_gpio_chips[2];
+static int cns3xxx_gpio_chip_count;
+
+static inline void
+__set_direction(struct cns3xxx_gpio_chip *cchip, unsigned pin, int input)
+{
+	u32 reg;
+
+	reg = __raw_readl(cchip->base + GPIO_DIR);
+	if (input)
+		reg &= ~(1 << pin);
+	else
+		reg |= (1 << pin);
+	__raw_writel(reg, cchip->base + GPIO_DIR);
+}
+
+/*
+ * GENERIC_GPIO primatives
+ */
+static int cns3xxx_gpio_direction_input(struct gpio_chip *chip, unsigned pin)
+{
+	struct cns3xxx_gpio_chip *cchip =
+		container_of(chip, struct cns3xxx_gpio_chip, chip);
+	unsigned long flags;
+
+	spin_lock_irqsave(&cchip->lock, flags);
+	__set_direction(cchip, pin, 1);
+	spin_unlock_irqrestore(&cchip->lock, flags);
+
+	return 0;
+}
+
+static int cns3xxx_gpio_get(struct gpio_chip *chip, unsigned pin)
+{
+	struct cns3xxx_gpio_chip *cchip =
+		container_of(chip, struct cns3xxx_gpio_chip, chip);
+	int val;
+
+	val = ((__raw_readl(cchip->base + GPIO_INPUT) >> pin) & 0x1);
+
+	return val;
+}
+
+static int cns3xxx_gpio_direction_output(struct gpio_chip *chip, unsigned pin, int level)
+{
+	struct cns3xxx_gpio_chip *cchip =
+		container_of(chip, struct cns3xxx_gpio_chip, chip);
+	unsigned long flags;
+
+	spin_lock_irqsave(&cchip->lock, flags);
+	if (level)
+		__raw_writel(1 << pin, cchip->base + GPIO_SET);
+	else
+		__raw_writel(1 << pin, cchip->base + GPIO_CLEAR);
+	__set_direction(cchip, pin, 0);
+	spin_unlock_irqrestore(&cchip->lock, flags);
+
+	return 0;
+}
+
+static void cns3xxx_gpio_set(struct gpio_chip *chip, unsigned pin,
+	int level)
+{
+	struct cns3xxx_gpio_chip *cchip =
+		container_of(chip, struct cns3xxx_gpio_chip, chip);
+
+	if (level)
+		__raw_writel(1 << pin, cchip->base + GPIO_SET);
+	else
+		__raw_writel(1 << pin, cchip->base + GPIO_CLEAR);
+}
+
+static int cns3xxx_gpio_to_irq(struct gpio_chip *chip, unsigned pin)
+{
+	struct cns3xxx_gpio_chip *cchip =
+		container_of(chip, struct cns3xxx_gpio_chip, chip);
+
+	return irq_find_mapping(cchip->domain, pin);
+}
+
+
+/*
+ * IRQ support
+ */
+
+/* one interrupt per GPIO controller (GPIOA/GPIOB)
+ * this is called in task context, with IRQs enabled
+ */
+static void cns3xxx_gpio_irq_handler(struct irq_desc *desc)
+{
+	struct cns3xxx_gpio_chip *cchip = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	u16 i;
+	u32 reg;
+
+	chained_irq_enter(chip, desc); /* mask and ack the base interrupt */
+
+	/* see which pin(s) triggered the interrupt */
+	reg = __raw_readl(cchip->base + GPIO_INTERRUPT_RAW_STATUS);
+	for (i = 0; i < 32; i++) {
+		if (reg & (1 << i)) {
+			/* let the generic IRQ layer handle an interrupt */
+			generic_handle_irq(irq_find_mapping(cchip->domain, i));
+		}
+	}
+
+	chained_irq_exit(chip, desc); /* unmask the base interrupt */
+}
+
+static int cns3xxx_gpio_irq_set_type(struct irq_data *d, u32 irqtype)
+{
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
+	struct cns3xxx_gpio_chip *cchip = gc->private;
+	u32 gpio = d->hwirq;
+	unsigned long flags;
+	u32 method, edges, type;
+
+	spin_lock_irqsave(&cchip->lock, flags);
+	method = __raw_readl(cchip->base + GPIO_INTERRUPT_TRIGGER_METHOD);
+	edges  = __raw_readl(cchip->base + GPIO_INTERRUPT_TRIGGER_BOTH_EDGES);
+	type   = __raw_readl(cchip->base + GPIO_INTERRUPT_TRIGGER_TYPE);
+	method &= ~(1 << gpio);
+	edges  &= ~(1 << gpio);
+	type   &= ~(1 << gpio);
+
+	switch(irqtype) {
+	case IRQ_TYPE_EDGE_RISING:
+		method |= (GPIO_INTERRUPT_TRIGGER_METHOD_EDGE << gpio);
+		edges  |= (GPIO_INTERRUPT_TRIGGER_EDGE_SINGLE << gpio);
+		type   |= (GPIO_INTERRUPT_TRIGGER_TYPE_RISING << gpio);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		method |= (GPIO_INTERRUPT_TRIGGER_METHOD_EDGE << gpio);
+		edges  |= (GPIO_INTERRUPT_TRIGGER_EDGE_SINGLE << gpio);
+		type   |= (GPIO_INTERRUPT_TRIGGER_TYPE_FALLING << gpio);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		method |= (GPIO_INTERRUPT_TRIGGER_METHOD_EDGE << gpio);
+		edges  |= (GPIO_INTERRUPT_TRIGGER_EDGE_BOTH << gpio);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		method |= (GPIO_INTERRUPT_TRIGGER_METHOD_LEVEL << gpio);
+		type   |= (GPIO_INTERRUPT_TRIGGER_TYPE_LOW << gpio);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		method |= (GPIO_INTERRUPT_TRIGGER_METHOD_LEVEL << gpio);
+		type   |= (GPIO_INTERRUPT_TRIGGER_TYPE_HIGH << gpio);
+		break;
+	default:
+		printk(KERN_WARNING "No irq type\n");
+		spin_unlock_irqrestore(&cchip->lock, flags);
+		return -EINVAL;
+	}
+
+	__raw_writel(method, cchip->base + GPIO_INTERRUPT_TRIGGER_METHOD);
+	__raw_writel(edges,  cchip->base + GPIO_INTERRUPT_TRIGGER_BOTH_EDGES);
+	__raw_writel(type,   cchip->base + GPIO_INTERRUPT_TRIGGER_TYPE);
+	spin_unlock_irqrestore(&cchip->lock, flags);
+
+	if (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))
+		irq_set_handler_locked(d, handle_level_irq);
+	else if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))
+		irq_set_handler_locked(d, handle_edge_irq);
+
+	return 0;
+}
+
+void __init cns3xxx_gpio_init(int gpio_base, int ngpio,
+	u32 base, int irq, int secondary_irq_base)
+{
+	struct cns3xxx_gpio_chip *cchip;
+	struct irq_chip_generic *gc;
+	struct irq_chip_type *ct;
+	char gc_label[16];
+	int irq_base;
+
+	if (cns3xxx_gpio_chip_count == ARRAY_SIZE(cns3xxx_gpio_chips))
+		return;
+
+	snprintf(gc_label, sizeof(gc_label), "cns3xxx_gpio%d",
+		cns3xxx_gpio_chip_count);
+
+	cchip = cns3xxx_gpio_chips + cns3xxx_gpio_chip_count;
+	cchip->chip.label = kstrdup(gc_label, GFP_KERNEL);
+	cchip->chip.direction_input = cns3xxx_gpio_direction_input;
+	cchip->chip.get = cns3xxx_gpio_get;
+	cchip->chip.direction_output = cns3xxx_gpio_direction_output;
+	cchip->chip.set = cns3xxx_gpio_set;
+	cchip->chip.to_irq = cns3xxx_gpio_to_irq;
+	cchip->chip.base = gpio_base;
+	cchip->chip.ngpio = ngpio;
+	cchip->chip.can_sleep = 0;
+	spin_lock_init(&cchip->lock);
+	cchip->base = (void __iomem *)base;
+
+	BUG_ON(gpiochip_add(&cchip->chip) < 0);
+	cns3xxx_gpio_chip_count++;
+
+	/* clear GPIO interrupts */
+	__raw_writel(0xffff, cchip->base + GPIO_INTERRUPT_CLEAR);
+
+	irq_base = irq_alloc_descs(-1, secondary_irq_base, ngpio,
+		numa_node_id());
+	if (irq_base < 0)
+		goto out_irqdesc_free;
+
+	cchip->domain = irq_domain_add_legacy(NULL, ngpio, irq_base, 0,
+		&irq_domain_simple_ops, NULL);
+	if (!cchip->domain)
+		goto out_irqdesc_free;
+
+	/*
+	 * IRQ chip init
+	 */
+	gc = irq_alloc_generic_chip("cns3xxx_gpio_irq", 1, irq_base,
+		cchip->base, handle_edge_irq);
+
+	gc->private = cchip;
+
+	ct = gc->chip_types;
+	ct->type = IRQ_TYPE_EDGE_FALLING;
+	ct->regs.ack = GPIO_INTERRUPT_CLEAR;
+	ct->regs.enable = GPIO_INTERRUPT_ENABLE;
+	ct->chip.irq_ack = irq_gc_ack_set_bit;
+	ct->chip.irq_enable = irq_gc_unmask_enable_reg;
+	ct->chip.irq_disable = irq_gc_mask_disable_reg;
+	ct->chip.irq_set_type = cns3xxx_gpio_irq_set_type;
+	ct->handler = handle_edge_irq;
+
+	irq_setup_generic_chip(gc, IRQ_MSK(ngpio), IRQ_GC_INIT_MASK_CACHE,
+		IRQ_NOREQUEST, 0);
+	irq_set_chained_handler(irq, cns3xxx_gpio_irq_handler);
+	irq_set_handler_data(irq, cchip);
+
+	return;
+
+out_irqdesc_free:
+	irq_free_descs(irq_base, ngpio);
+}
diff --git a/arch/arm/mach-cns3xxx/headsmp.S b/arch/arm/mach-cns3xxx/headsmp.S
new file mode 100644
index 00000000..f0da8ec0
--- /dev/null
+++ b/arch/arm/mach-cns3xxx/headsmp.S
@@ -0,0 +1,41 @@
+/*
+ *  linux/arch/arm/mach-cns3xxx/headsmp.S
+ *
+ *  Cloned from linux/arch/arm/plat-versatile/headsmp.S
+ *
+ *  Copyright (c) 2003 ARM Limited
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+/*
+ * CNS3XXX specific entry point for secondary CPUs.  This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+ENTRY(cns3xxx_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
+ENDPROC(cns3xxx_secondary_startup)
+
+	.align 2
+1:	.long	.
+	.long	pen_release
diff --git a/arch/arm/mach-cns3xxx/hotplug.c b/arch/arm/mach-cns3xxx/hotplug.c
new file mode 100644
index 00000000..be0d499a
--- /dev/null
+++ b/arch/arm/mach-cns3xxx/hotplug.c
@@ -0,0 +1,130 @@
+/* linux arch/arm/mach-cns3xxx/hotplug.c
+ *
+ *  Cloned from linux/arch/arm/mach-realview/hotplug.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+
+#include <asm/cacheflush.h>
+
+extern volatile int pen_release;
+
+static inline void cpu_enter_lowpower(void)
+{
+	unsigned int v;
+
+	flush_cache_all();
+	asm volatile(
+	"	mcr	p15, 0, %1, c7, c5, 0\n"
+	"	mcr	p15, 0, %1, c7, c10, 4\n"
+	/*
+	 * Turn off coherency
+	 */
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	bic	%0, %0, %3\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	"	mrc	p15, 0, %0, c1, c0, 0\n"
+	"	bic	%0, %0, %2\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	  : "=&r" (v)
+	  : "r" (0), "Ir" (CR_C), "Ir" (0x40)
+	  : "cc");
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+	unsigned int v;
+
+	asm volatile(
+	"mrc	p15, 0, %0, c1, c0, 0\n"
+	"	orr	%0, %0, %1\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	orr	%0, %0, %2\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	  : "=&r" (v)
+	  : "Ir" (CR_C), "Ir" (0x40)
+	  : "cc");
+}
+
+static inline void platform_do_lowpower(unsigned int cpu, int *spurious)
+{
+	/*
+	 * there is no power-control hardware on this platform, so all
+	 * we can do is put the core into WFI; this is safe as the calling
+	 * code will have already disabled interrupts
+	 */
+	for (;;) {
+		/*
+		 * here's the WFI
+		 */
+		asm(".word	0xe320f003\n"
+		    :
+		    :
+		    : "memory", "cc");
+
+		if (pen_release == cpu) {
+			/*
+			 * OK, proper wakeup, we're done
+			 */
+			break;
+		}
+
+		/*
+		 * Getting here, means that we have come out of WFI without
+		 * having been woken up - this shouldn't happen
+		 *
+		 * Just note it happening - when we're woken, we can report
+		 * its occurrence.
+		 */
+		(*spurious)++;
+	}
+}
+
+int platform_cpu_kill(unsigned int cpu)
+{
+	return 1;
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void platform_cpu_die(unsigned int cpu)
+{
+	int spurious = 0;
+
+	/*
+	 * we're ready for shutdown now, so do it
+	 */
+	cpu_enter_lowpower();
+	platform_do_lowpower(cpu, &spurious);
+
+	/*
+	 * bring this CPU back into the world of cache
+	 * coherency, and then restore interrupts
+	 */
+	cpu_leave_lowpower();
+
+	if (spurious)
+		pr_warn("CPU%u: %u spurious wakeup calls\n", cpu, spurious);
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * we don't allow CPU 0 to be shutdown (it is still too special
+	 * e.g. clock tick interrupts)
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-cns3xxx/include/mach/gpio.h b/arch/arm/mach-cns3xxx/include/mach/gpio.h
new file mode 100644
index 00000000..8c66748a
--- /dev/null
+++ b/arch/arm/mach-cns3xxx/include/mach/gpio.h
@@ -0,0 +1,17 @@
+/*
+ * arch/arm/mach-cns3xxx/include/mach/gpio.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ */
+#ifndef __ASM_ARCH_CNS3XXX_GPIO_H
+#define __ASM_ARCH_CNS3XXX_GPIO_H
+
+#include <linux/kernel.h>
+
+extern void __init cns3xxx_gpio_init(int gpio_base, int ngpio,
+	u32 base, int irq, int secondary_irq_base);
+
+#endif
diff --git a/arch/arm/mach-cns3xxx/include/mach/smp.h b/arch/arm/mach-cns3xxx/include/mach/smp.h
new file mode 100644
index 00000000..e5bc5682
--- /dev/null
+++ b/arch/arm/mach-cns3xxx/include/mach/smp.h
@@ -0,0 +1,8 @@
+#ifndef __MACH_SMP_H
+#define __MACH_SMP_H
+
+extern void smp_dma_map_area(const void *, size_t, int);
+extern void smp_dma_unmap_area(const void *, size_t, int);
+extern void smp_dma_flush_range(const void *, const void *);
+
+#endif
diff --git a/arch/arm/mach-cns3xxx/laguna.c b/arch/arm/mach-cns3xxx/laguna.c
new file mode 100644
index 00000000..6c779233
--- /dev/null
+++ b/arch/arm/mach-cns3xxx/laguna.c
@@ -0,0 +1,1081 @@
+/*
+ * Gateworks Corporation Laguna Platform
+ *
+ * Copyright 2000 Deep Blue Solutions Ltd
+ * Copyright 2008 ARM Limited
+ * Copyright 2008 Cavium Networks
+ *		  Scott Shu
+ * Copyright 2010 MontaVista Software, LLC.
+ *		  Anton Vorontsov <avorontsov@mvista.com>
+ * Copyright 2011 Gateworks Corporation
+ *		  Chris Lang <clang@gateworks.com>
+ * Copyright 2012-2013 Gateworks Corporation
+ *		  Tim Harvey <tharvey@gateworks.com>
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/compiler.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/dma-mapping.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+#include <linux/leds.h>
+#include <linux/i2c.h>
+#include <linux/platform_data/at24.h>
+#include <linux/platform_data/pca953x.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/if_ether.h>
+#include <linux/pps-gpio.h>
+#include <linux/usb/ehci_pdriver.h>
+#include <linux/usb/ohci_pdriver.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/platform_data/cns3xxx.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <mach/gpio.h>
+#include "core.h"
+#include "devices.h"
+#include "cns3xxx.h"
+#include "pm.h"
+
+#define ARRAY_AND_SIZE(x)       (x), ARRAY_SIZE(x)
+
+// Config 1 Bitmap
+#define ETH0_LOAD           BIT(0)
+#define ETH1_LOAD           BIT(1)
+#define ETH2_LOAD           BIT(2)
+#define SATA0_LOAD          BIT(3)
+#define SATA1_LOAD          BIT(4)
+#define PCM_LOAD            BIT(5)
+#define I2S_LOAD            BIT(6)
+#define SPI0_LOAD           BIT(7)
+#define SPI1_LOAD           BIT(8)
+#define PCIE0_LOAD          BIT(9)
+#define PCIE1_LOAD          BIT(10)
+#define USB0_LOAD           BIT(11)
+#define USB1_LOAD           BIT(12)
+#define USB1_ROUTE          BIT(13)
+#define SD_LOAD             BIT(14)
+#define UART0_LOAD          BIT(15)
+#define UART1_LOAD          BIT(16)
+#define UART2_LOAD          BIT(17)
+#define MPCI0_LOAD          BIT(18)
+#define MPCI1_LOAD          BIT(19)
+#define MPCI2_LOAD          BIT(20)
+#define MPCI3_LOAD          BIT(21)
+#define FP_BUT_LOAD         BIT(22)
+#define FP_BUT_HEADER_LOAD  BIT(23)
+#define FP_LED_LOAD         BIT(24)
+#define FP_LED_HEADER_LOAD  BIT(25)
+#define FP_TAMPER_LOAD      BIT(26)
+#define HEADER_33V_LOAD     BIT(27)
+#define SATA_POWER_LOAD     BIT(28)
+#define FP_POWER_LOAD       BIT(29)
+#define GPIO_HEADER_LOAD    BIT(30)
+#define GSP_BAT_LOAD        BIT(31)
+
+// Config 2 Bitmap
+#define FAN_LOAD            BIT(0)
+#define SPI_FLASH_LOAD      BIT(1)
+#define NOR_FLASH_LOAD      BIT(2)
+#define GPS_LOAD            BIT(3)
+#define SUPPLY_5V_LOAD      BIT(6)
+#define SUPPLY_33V_LOAD     BIT(7)
+
+struct laguna_board_info {
+	char model[16];
+	u32 config_bitmap;
+	u32 config2_bitmap;
+	u8 nor_flash_size;
+	u8 spi_flash_size;
+};
+
+static struct laguna_board_info laguna_info __initdata;
+
+/*
+ * NOR Flash
+ */
+static struct mtd_partition laguna_nor_partitions[] = {
+	{
+		.name		= "uboot",
+		.size		= SZ_256K,
+		.offset		= 0,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "params",
+		.size		= SZ_128K,
+		.offset		= SZ_256K,
+	}, {
+		.name		= "kernel",
+		.size		= SZ_2M,
+		.offset		= SZ_256K + SZ_128K,
+	}, {
+		.name		= "rootfs",
+		.size		= SZ_16M - SZ_256K - SZ_128K - SZ_2M,
+		.offset		= SZ_256K + SZ_128K + SZ_2M,
+	},
+};
+
+static struct physmap_flash_data laguna_nor_pdata = {
+	.width = 2,
+	.parts = laguna_nor_partitions,
+	.nr_parts = ARRAY_SIZE(laguna_nor_partitions),
+};
+
+static struct resource laguna_nor_res = {
+	.start = CNS3XXX_FLASH_BASE,
+	.end = CNS3XXX_FLASH_BASE + SZ_128M - 1,
+	.flags = IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
+};
+
+static struct platform_device laguna_nor_pdev = {
+	.name = "physmap-flash",
+	.id = 0,
+	.resource = &laguna_nor_res,
+	.num_resources = 1,
+	.dev = {
+		.platform_data = &laguna_nor_pdata,
+	},
+};
+
+/*
+ * SPI
+ */
+static struct mtd_partition laguna_spi_partitions[] = {
+	{
+		.name		= "uboot",
+		.size		= SZ_256K,
+		.offset		= 0,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "params",
+		.size		= SZ_256K,
+		.offset		= SZ_256K,
+	}, {
+		.name		= "kernel",
+		.size		= SZ_1M + SZ_512K,
+		.offset		= SZ_512K,
+	}, {
+		.name		= "rootfs",
+		.size		= SZ_16M - SZ_2M,
+		.offset		= SZ_2M,
+	},
+};
+
+static struct flash_platform_data laguna_spi_pdata = {
+	.parts = laguna_spi_partitions,
+	.nr_parts = ARRAY_SIZE(laguna_spi_partitions),
+};
+
+static struct spi_board_info __initdata laguna_spi_devices[] = {
+	{
+		.modalias = "m25p80",
+		.platform_data = &laguna_spi_pdata,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+		.chip_select = 0,
+	},
+};
+
+static struct resource laguna_spi_resource = {
+	.start    = CNS3XXX_SSP_BASE + 0x40,
+	.end      = CNS3XXX_SSP_BASE + 0x6f,
+	.flags    = IORESOURCE_MEM,
+};
+
+static struct platform_device laguna_spi_controller = {
+	.name = "cns3xxx_spi",
+	.resource = &laguna_spi_resource,
+	.num_resources = 1,
+};
+
+/*
+ * LED's
+ */
+static struct gpio_led laguna_gpio_leds[] = {
+	{
+		.name = "user1", /* Green Led */
+		.gpio = 115,
+		.active_low = 1,
+	},{
+		.name = "user2", /* Red Led */
+		.gpio = 114,
+		.active_low = 1,
+	},{
+		.name = "pwr1", /* Green Led */
+		.gpio = 116,
+		.active_low = 1,
+	},{
+		.name = "pwr2", /* Yellow Led */
+		.gpio = 117,
+		.active_low = 1,
+	},{
+		.name = "txd1", /* Green Led */
+		.gpio = 118,
+		.active_low = 1,
+	},{
+		.name = "txd2", /* Yellow Led */
+		.gpio = 119,
+		.active_low = 1,
+	},{
+		.name = "rxd1", /* Green Led */
+		.gpio = 120,
+		.active_low = 1,
+	},{
+		.name = "rxd2", /* Yellow Led */
+		.gpio = 121,
+		.active_low = 1,
+	},{
+		.name = "ser1", /* Green Led */
+		.gpio = 122,
+		.active_low = 1,
+	},{
+		.name = "ser2", /* Yellow Led */
+		.gpio = 123,
+		.active_low = 1,
+	},{
+		.name = "enet1", /* Green Led */
+		.gpio = 124,
+		.active_low = 1,
+	},{
+		.name = "enet2", /* Yellow Led */
+		.gpio = 125,
+		.active_low = 1,
+	},{
+		.name = "sig1_1", /* Green Led */
+		.gpio = 126,
+		.active_low = 1,
+	},{
+		.name = "sig1_2", /* Yellow Led */
+		.gpio = 127,
+		.active_low = 1,
+	},{
+		.name = "sig2_1", /* Green Led */
+		.gpio = 128,
+		.active_low = 1,
+	},{
+		.name = "sig2_2", /* Yellow Led */
+		.gpio = 129,
+		.active_low = 1,
+	},{
+		.name = "sig3_1", /* Green Led */
+		.gpio = 130,
+		.active_low = 1,
+	},{
+		.name = "sig3_2", /* Yellow Led */
+		.gpio = 131,
+		.active_low = 1,
+	},{
+		.name = "net1", /*Green Led */
+		.gpio = 109,
+		.active_low = 1,
+	},{
+		.name = "net2", /* Red Led */
+		.gpio = 110,
+		.active_low = 1,
+	},{
+		.name = "mod1", /* Green Led */
+		.gpio = 111,
+		.active_low = 1,
+	},{
+		.name = "mod2", /* Red Led */
+		.gpio = 112,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_led_platform_data laguna_gpio_leds_data = {
+	.num_leds = 22,
+	.leds = laguna_gpio_leds,
+};
+
+static struct platform_device laguna_gpio_leds_device = {
+	.name = "leds-gpio",
+	.id = -1,
+	.dev.platform_data = &laguna_gpio_leds_data,
+};
+
+/*
+ * Ethernet
+ */
+static struct cns3xxx_plat_info laguna_net_data = {
+	.ports = 0,
+	.phy = {
+		0,
+		1,
+		2,
+	},
+};
+
+static struct resource laguna_net_resource[] = {
+	{
+		.name = "eth0_mem",
+		.start = CNS3XXX_SWITCH_BASE,
+		.end = CNS3XXX_SWITCH_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM
+	}, {
+		.name = "eth_rx",
+		.start = IRQ_CNS3XXX_SW_R0RXC,
+		.end = IRQ_CNS3XXX_SW_R0RXC,
+		.flags = IORESOURCE_IRQ
+	}, {
+		.name = "eth_stat",
+		.start = IRQ_CNS3XXX_SW_STATUS,
+		.end = IRQ_CNS3XXX_SW_STATUS,
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+static u64 laguna_net_dmamask = DMA_BIT_MASK(32);
+static struct platform_device laguna_net_device = {
+	.name = "cns3xxx_eth",
+	.id = 0,
+	.resource = laguna_net_resource,
+	.num_resources = ARRAY_SIZE(laguna_net_resource),
+	.dev = {
+		.dma_mask = &laguna_net_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &laguna_net_data,
+	}
+};
+
+/*
+ * UART
+ */
+static void __init laguna_early_serial_setup(void)
+{
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	static struct uart_port laguna_serial_port = {
+		.membase        = (void __iomem *)CNS3XXX_UART0_BASE_VIRT,
+		.mapbase        = CNS3XXX_UART0_BASE,
+		.irq            = IRQ_CNS3XXX_UART0,
+		.iotype         = UPIO_MEM,
+		.flags          = UPF_BOOT_AUTOCONF | UPF_FIXED_TYPE,
+		.regshift       = 2,
+		.uartclk        = 24000000,
+		.line           = 0,
+		.type           = PORT_16550A,
+		.fifosize       = 16,
+	};
+
+	early_serial_setup(&laguna_serial_port);
+#endif
+}
+
+static struct resource laguna_uart_resources[] = {
+	{
+		.start = CNS3XXX_UART0_BASE,
+		.end   = CNS3XXX_UART0_BASE + SZ_4K - 1,
+		.flags    = IORESOURCE_MEM
+	},{
+		.start = CNS3XXX_UART2_BASE,
+		.end   = CNS3XXX_UART2_BASE + SZ_4K - 1,
+		.flags    = IORESOURCE_MEM
+	},{
+		.start = CNS3XXX_UART2_BASE,
+		.end   = CNS3XXX_UART2_BASE + SZ_4K - 1,
+		.flags    = IORESOURCE_MEM
+	},
+};
+
+static struct plat_serial8250_port laguna_uart_data[] = {
+	{
+		.mapbase        = (CNS3XXX_UART0_BASE),
+		.irq            = IRQ_CNS3XXX_UART0,
+		.iotype         = UPIO_MEM,
+		.flags          = UPF_BOOT_AUTOCONF | UPF_FIXED_TYPE | UPF_NO_TXEN_TEST | UPF_IOREMAP,
+		.regshift       = 2,
+		.uartclk        = 24000000,
+		.type           = PORT_16550A,
+	},{
+		.mapbase        = (CNS3XXX_UART1_BASE),
+		.irq            = IRQ_CNS3XXX_UART1,
+		.iotype         = UPIO_MEM,
+		.flags          = UPF_BOOT_AUTOCONF | UPF_FIXED_TYPE | UPF_NO_TXEN_TEST | UPF_IOREMAP,
+		.regshift       = 2,
+		.uartclk        = 24000000,
+		.type           = PORT_16550A,
+	},{
+		.mapbase        = (CNS3XXX_UART2_BASE),
+		.irq            = IRQ_CNS3XXX_UART2,
+		.iotype         = UPIO_MEM,
+		.flags          = UPF_BOOT_AUTOCONF | UPF_FIXED_TYPE | UPF_NO_TXEN_TEST | UPF_IOREMAP,
+		.regshift       = 2,
+		.uartclk        = 24000000,
+		.type           = PORT_16550A,
+	},
+	{ },
+};
+
+static struct platform_device laguna_uart = {
+	.name     = "serial8250",
+	.id     = PLAT8250_DEV_PLATFORM,
+	.dev.platform_data  = laguna_uart_data,
+	.num_resources    = 3,
+	.resource   = laguna_uart_resources
+};
+
+/*
+ * USB
+ */
+static struct resource cns3xxx_usb_ehci_resources[] = {
+	[0] = {
+		.start = CNS3XXX_USB_BASE,
+		.end   = CNS3XXX_USB_BASE + SZ_16M - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_CNS3XXX_USB_EHCI,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 cns3xxx_usb_ehci_dma_mask = DMA_BIT_MASK(32);
+
+static int csn3xxx_usb_power_on(struct platform_device *pdev)
+{
+	/*
+	 * EHCI and OHCI share the same clock and power,
+	 * resetting twice would cause the 1st controller been reset.
+	 * Therefore only do power up  at the first up device, and
+	 * power down at the last down device.
+	 *
+	 * Set USB AHB INCR length to 16
+	 */
+	if (atomic_inc_return(&usb_pwr_ref) == 1) {
+		cns3xxx_pwr_power_up(1 << PM_PLL_HM_PD_CTRL_REG_OFFSET_PLL_USB);
+		cns3xxx_pwr_clk_en(1 << PM_CLK_GATE_REG_OFFSET_USB_HOST);
+		cns3xxx_pwr_soft_rst(1 << PM_SOFT_RST_REG_OFFST_USB_HOST);
+		__raw_writel((__raw_readl(MISC_CHIP_CONFIG_REG) | (0X2 << 24)),
+			MISC_CHIP_CONFIG_REG);
+	}
+
+	return 0;
+}
+
+static void csn3xxx_usb_power_off(struct platform_device *pdev)
+{
+	/*
+	 * EHCI and OHCI share the same clock and power,
+	 * resetting twice would cause the 1st controller been reset.
+	 * Therefore only do power up  at the first up device, and
+	 * power down at the last down device.
+	 */
+	if (atomic_dec_return(&usb_pwr_ref) == 0)
+		cns3xxx_pwr_clk_dis(1 << PM_CLK_GATE_REG_OFFSET_USB_HOST);
+}
+
+static struct usb_ehci_pdata cns3xxx_usb_ehci_pdata = {
+	.power_on	= csn3xxx_usb_power_on,
+	.power_off	= csn3xxx_usb_power_off,
+};
+
+static struct platform_device cns3xxx_usb_ehci_device = {
+	.name          = "ehci-platform",
+	.num_resources = ARRAY_SIZE(cns3xxx_usb_ehci_resources),
+	.resource      = cns3xxx_usb_ehci_resources,
+	.dev           = {
+		.dma_mask          = &cns3xxx_usb_ehci_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data     = &cns3xxx_usb_ehci_pdata,
+	},
+};
+
+static struct resource cns3xxx_usb_ohci_resources[] = {
+	[0] = {
+		.start = CNS3XXX_USB_OHCI_BASE,
+		.end   = CNS3XXX_USB_OHCI_BASE + SZ_16M - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_CNS3XXX_USB_OHCI,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 cns3xxx_usb_ohci_dma_mask = DMA_BIT_MASK(32);
+
+static struct usb_ohci_pdata cns3xxx_usb_ohci_pdata = {
+	.num_ports	= 1,
+	.power_on	= csn3xxx_usb_power_on,
+	.power_off	= csn3xxx_usb_power_off,
+};
+
+static struct platform_device cns3xxx_usb_ohci_device = {
+	.name          = "ohci-platform",
+	.num_resources = ARRAY_SIZE(cns3xxx_usb_ohci_resources),
+	.resource      = cns3xxx_usb_ohci_resources,
+	.dev           = {
+		.dma_mask          = &cns3xxx_usb_ohci_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data	   = &cns3xxx_usb_ohci_pdata,
+	},
+};
+
+static struct resource cns3xxx_usb_otg_resources[] = {
+	[0] = {
+		.start = CNS3XXX_USBOTG_BASE,
+		.end   = CNS3XXX_USBOTG_BASE + SZ_16M - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_CNS3XXX_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 cns3xxx_usb_otg_dma_mask = DMA_BIT_MASK(32);
+
+static struct platform_device cns3xxx_usb_otg_device = {
+	.name          = "dwc2",
+	.num_resources = ARRAY_SIZE(cns3xxx_usb_otg_resources),
+	.resource      = cns3xxx_usb_otg_resources,
+	.dev           = {
+		.dma_mask          = &cns3xxx_usb_otg_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
+/*
+ * I2C
+ */
+static struct resource laguna_i2c_resource[] = {
+	{
+		.start    = CNS3XXX_SSP_BASE + 0x20,
+		.end      = CNS3XXX_SSP_BASE + 0x3f,
+		.flags    = IORESOURCE_MEM,
+	},{
+		.start    = IRQ_CNS3XXX_I2C,
+		.flags    = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device laguna_i2c_controller = {
+	.name   = "cns3xxx-i2c",
+	.num_resources  = 2,
+	.resource = laguna_i2c_resource,
+};
+
+static struct memory_accessor *at24_mem_acc;
+
+static void at24_setup(struct memory_accessor *mem_acc, void *context)
+{
+	char buf[16];
+
+	at24_mem_acc = mem_acc;
+
+	/* Read MAC addresses */
+	if (at24_mem_acc->read(at24_mem_acc, buf, 0x100, 6) == 6)
+		memcpy(&laguna_net_data.hwaddr[0], buf, ETH_ALEN);
+	if (at24_mem_acc->read(at24_mem_acc, buf, 0x106, 6) == 6)
+		memcpy(&laguna_net_data.hwaddr[1], buf, ETH_ALEN);
+	if (at24_mem_acc->read(at24_mem_acc, buf, 0x10C, 6) == 6)
+		memcpy(&laguna_net_data.hwaddr[2], buf, ETH_ALEN);
+	if (at24_mem_acc->read(at24_mem_acc, buf, 0x112, 6) == 6)
+		memcpy(&laguna_net_data.hwaddr[3], buf, ETH_ALEN);
+
+	/* Read out Model Information */
+	if (at24_mem_acc->read(at24_mem_acc, buf, 0x130, 16) == 16)
+		memcpy(&laguna_info.model, buf, 16);
+	if (at24_mem_acc->read(at24_mem_acc, buf, 0x140, 1) == 1)
+		memcpy(&laguna_info.nor_flash_size, buf, 1);
+	if (at24_mem_acc->read(at24_mem_acc, buf, 0x141, 1) == 1)
+		memcpy(&laguna_info.spi_flash_size, buf, 1);
+	if (at24_mem_acc->read(at24_mem_acc, buf, 0x142, 4) == 4)
+		memcpy(&laguna_info.config_bitmap, buf, 4);
+	if (at24_mem_acc->read(at24_mem_acc, buf, 0x146, 4) == 4)
+		memcpy(&laguna_info.config2_bitmap, buf, 4);
+};
+
+static struct at24_platform_data laguna_eeprom_info = {
+	.byte_len = 1024,
+	.page_size = 16,
+	.flags = AT24_FLAG_READONLY,
+	.setup = at24_setup,
+};
+
+static struct pca953x_platform_data laguna_pca_data = {
+ 	.gpio_base = 100,
+	.irq_base = -1,
+};
+
+static struct pca953x_platform_data laguna_pca2_data = {
+ 	.gpio_base = 116,
+	.irq_base = -1,
+};
+
+static struct i2c_board_info __initdata laguna_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("pca9555", 0x23),
+		.platform_data = &laguna_pca_data,
+	},{
+		I2C_BOARD_INFO("pca9555", 0x27),
+		.platform_data = &laguna_pca2_data,
+	},{
+		I2C_BOARD_INFO("gsp", 0x29),
+	},{
+		I2C_BOARD_INFO ("24c08",0x50),
+		.platform_data = &laguna_eeprom_info,
+	},{
+		I2C_BOARD_INFO("ds1672", 0x68),
+	},
+};
+
+/*
+ * Watchdog
+ */
+
+static struct resource laguna_watchdog_resources[] = {
+	[0] = {
+		.start	= CNS3XXX_TC11MP_TWD_BASE + 0x100, // CPU0 watchdog
+		.end	= CNS3XXX_TC11MP_TWD_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device laguna_watchdog = {
+	.name		= "mpcore_wdt",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(laguna_watchdog_resources),
+	.resource	= laguna_watchdog_resources,
+};
+
+/*
+ * GPS PPS
+ */
+static struct pps_gpio_platform_data laguna_pps_data = {
+	.gpio_pin = 0,
+	.gpio_label = "GPS_PPS",
+	.assert_falling_edge = 0,
+	.capture_clear = 0,
+};
+
+static struct platform_device laguna_pps_device = {
+	.name = "pps-gpio",
+	.id = -1,
+	.dev.platform_data = &laguna_pps_data,
+};
+
+/*
+ * GPIO
+ */
+
+static struct gpio laguna_gpio_gw2391[] = {
+	{   0, GPIOF_IN           , "*GPS_PPS" },
+	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+	{   2, GPIOF_IN           , "*USB_FAULT#" },
+	{   5, GPIOF_OUT_INIT_LOW , "*USB0_PCI_SEL" },
+	{   6, GPIOF_OUT_INIT_HIGH, "*USB_VBUS_EN" },
+	{   7, GPIOF_OUT_INIT_LOW , "*USB1_PCI_SEL" },
+	{   8, GPIOF_OUT_INIT_HIGH, "*PERST#" },
+	{   9, GPIOF_OUT_INIT_LOW , "*FP_SER_EN#" },
+	{ 100, GPIOF_IN           , "*USER_PB#" },
+	{ 103, GPIOF_OUT_INIT_HIGH, "*V5_EN" },
+	{ 108, GPIOF_IN           , "DIO0" },
+	{ 109, GPIOF_IN           , "DIO1" },
+	{ 110, GPIOF_IN           , "DIO2" },
+	{ 111, GPIOF_IN           , "DIO3" },
+	{ 112, GPIOF_IN           , "DIO4" },
+};
+
+static struct gpio laguna_gpio_gw2388[] = {
+	{   0, GPIOF_IN           , "*GPS_PPS" },
+	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+	{   3, GPIOF_IN           , "*USB_FAULT#" },
+	{   6, GPIOF_OUT_INIT_HIGH, "*USB_VBUS_EN" },
+	{   7, GPIOF_OUT_INIT_LOW , "*GSM_SEL0" },
+	{   8, GPIOF_OUT_INIT_LOW , "*GSM_SEL1" },
+	{   9, GPIOF_OUT_INIT_LOW , "*FP_SER_EN" },
+	{ 100, GPIOF_OUT_INIT_HIGH, "*USER_PB#" },
+	{ 108, GPIOF_IN           , "DIO0" },
+	{ 109, GPIOF_IN           , "DIO1" },
+	{ 110, GPIOF_IN           , "DIO2" },
+	{ 111, GPIOF_IN           , "DIO3" },
+	{ 112, GPIOF_IN           , "DIO4" },
+};
+
+static struct gpio laguna_gpio_gw2387[] = {
+	{   0, GPIOF_IN           , "*GPS_PPS" },
+	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+	{   2, GPIOF_IN           , "*USB_FAULT#" },
+	{   5, GPIOF_OUT_INIT_LOW , "*USB_PCI_SEL" },
+	{   6, GPIOF_OUT_INIT_HIGH, "*USB_VBUS_EN" },
+	{   7, GPIOF_OUT_INIT_LOW , "*GSM_SEL0" },
+	{   8, GPIOF_OUT_INIT_LOW , "*GSM_SEL1" },
+	{   9, GPIOF_OUT_INIT_LOW , "*FP_SER_EN" },
+	{ 100, GPIOF_IN           , "*USER_PB#" },
+	{ 103, GPIOF_OUT_INIT_HIGH, "*V5_EN" },
+	{ 108, GPIOF_IN           , "DIO0" },
+	{ 109, GPIOF_IN           , "DIO1" },
+	{ 110, GPIOF_IN           , "DIO2" },
+	{ 111, GPIOF_IN           , "DIO3" },
+	{ 112, GPIOF_IN           , "DIO4" },
+	{ 113, GPIOF_IN           , "DIO5" },
+};
+
+static struct gpio laguna_gpio_gw2385[] = {
+	{   0, GPIOF_IN           , "*GSC_IRQ#" },
+	{   1, GPIOF_OUT_INIT_HIGH, "*USB_HST_VBUS_EN" },
+	{   2, GPIOF_IN           , "*USB_HST_FAULT#" },
+	{   5, GPIOF_IN           , "*USB_OTG_FAULT#" },
+	{   6, GPIOF_OUT_INIT_LOW , "*USB_HST_PCI_SEL" },
+	{   7, GPIOF_OUT_INIT_LOW , "*GSM_SEL0" },
+	{   8, GPIOF_OUT_INIT_LOW , "*GSM_SEL1" },
+	{   9, GPIOF_OUT_INIT_LOW , "*SER_EN" },
+	{  10, GPIOF_IN,            "*USER_PB#" },
+	{  11, GPIOF_OUT_INIT_HIGH, "*PERST#" },
+	{ 100, GPIOF_IN           , "*USER_PB#" },
+	{ 103, GPIOF_OUT_INIT_HIGH, "V5_EN" },
+};
+
+static struct gpio laguna_gpio_gw2384[] = {
+	{   0, GPIOF_IN           , "*GSC_IRQ#" },
+	{   1, GPIOF_OUT_INIT_HIGH, "*USB_HST_VBUS_EN" },
+	{   2, GPIOF_IN           , "*USB_HST_FAULT#" },
+	{   5, GPIOF_IN           , "*USB_OTG_FAULT#" },
+	{   6, GPIOF_OUT_INIT_LOW , "*USB_HST_PCI_SEL" },
+	{   7, GPIOF_OUT_INIT_LOW , "*GSM_SEL0" },
+	{   8, GPIOF_OUT_INIT_LOW , "*GSM_SEL1" },
+	{   9, GPIOF_OUT_INIT_LOW , "*FP_SER_EN" },
+	{  12, GPIOF_OUT_INIT_LOW , "J10_DIOLED0" },
+	{  13, GPIOF_OUT_INIT_HIGH, "*I2CMUX_RST#" },
+	{  14, GPIOF_OUT_INIT_LOW , "J10_DIOLED1" },
+	{  15, GPIOF_OUT_INIT_LOW , "J10_DIOLED2" },
+	{ 100, GPIOF_IN           , "*USER_PB#" },
+	{ 103, GPIOF_OUT_INIT_HIGH, "V5_EN" },
+	{ 108, GPIOF_IN           , "J9_DIOGSC0" },
+};
+
+static struct gpio laguna_gpio_gw2383[] = {
+	{   0, GPIOF_IN           , "*GPS_PPS" },
+	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+	{   2, GPIOF_OUT_INIT_HIGH, "*PCIE_RST#" },
+	{   3, GPIOF_IN           , "GPIO0" },
+	{   8, GPIOF_IN           , "GPIO1" },
+	{ 100, GPIOF_IN           , "DIO0" },
+	{ 101, GPIOF_IN           , "DIO1" },
+	{ 108, GPIOF_IN           , "*USER_PB#" },
+};
+
+static struct gpio laguna_gpio_gw2382[] = {
+	{   0, GPIOF_IN           , "*GPS_PPS" },
+	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+	{   2, GPIOF_OUT_INIT_HIGH, "*PCIE_RST#" },
+	{   3, GPIOF_IN           , "GPIO0" },
+	{   4, GPIOF_IN           , "GPIO1" },
+	{   9, GPIOF_OUT_INIT_HIGH, "*USB_VBUS_EN" },
+	{  10, GPIOF_OUT_INIT_HIGH, "*USB_PCI_SEL#" },
+	{ 100, GPIOF_IN           , "DIO0" },
+	{ 101, GPIOF_IN           , "DIO1" },
+	{ 108, GPIOF_IN           , "*USER_PB#" },
+};
+
+static struct gpio laguna_gpio_gw2380[] = {
+	{   0, GPIOF_IN           , "*GPS_PPS" },
+	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+	{   3, GPIOF_IN           , "GPIO0" },
+	{   8, GPIOF_IN           , "GPIO1" },
+	{ 100, GPIOF_IN           , "DIO0" },
+	{ 101, GPIOF_IN           , "DIO1" },
+	{ 102, GPIOF_IN           , "DIO2" },
+	{ 103, GPIOF_IN           , "DIO3" },
+	{ 108, GPIOF_IN           , "*USER_PB#" },
+};
+
+/*
+ * Initialization
+ */
+static void __init laguna_init(void)
+{
+	struct clk *clk;
+	u32 __iomem *reg;
+
+	clk = clk_register_fixed_rate(NULL, "cpu", NULL,
+				      CLK_IS_ROOT | CLK_IGNORE_UNUSED,
+				      cns3xxx_cpu_clock() * (1000000 / 8));
+	clk_register_clkdev(clk, "cpu", NULL);
+
+	platform_device_register(&laguna_watchdog);
+
+	platform_device_register(&laguna_i2c_controller);
+
+	/* Set I2C 0-3 drive strength to 21 mA */
+	reg = MISC_IO_PAD_DRIVE_STRENGTH_CTRL_B;
+	*reg |= 0x300;
+
+	/* Enable SCL/SDA for I2C */
+	reg = MISC_GPIOB_PIN_ENABLE_REG;
+	*reg |= BIT(12) | BIT(13);
+
+	/* Enable MMC/SD pins */
+	*reg |= BIT(7) | BIT(8) | BIT(9) | BIT(10) | BIT(11);
+
+	cns3xxx_pwr_clk_en(1 << PM_CLK_GATE_REG_OFFSET_SPI_PCM_I2C);
+	cns3xxx_pwr_power_up(1 << PM_CLK_GATE_REG_OFFSET_SPI_PCM_I2C);
+	cns3xxx_pwr_soft_rst(1 << PM_CLK_GATE_REG_OFFSET_SPI_PCM_I2C);
+
+	cns3xxx_pwr_clk_en(CNS3XXX_PWR_CLK_EN(SPI_PCM_I2C));
+	cns3xxx_pwr_soft_rst(CNS3XXX_PWR_SOFTWARE_RST(SPI_PCM_I2C));
+
+	i2c_register_board_info(0, ARRAY_AND_SIZE(laguna_i2c_devices));
+
+	pm_power_off = cns3xxx_power_off;
+}
+
+static struct map_desc laguna_io_desc[] __initdata = {
+	{
+		.virtual	= CNS3XXX_UART0_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_UART0_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	},
+};
+
+static void __init laguna_map_io(void)
+{
+	cns3xxx_map_io();
+	cns3xxx_pcie_iotable_init();
+	iotable_init(ARRAY_AND_SIZE(laguna_io_desc));
+	laguna_early_serial_setup();
+}
+
+static int laguna_register_gpio(struct gpio *array, size_t num)
+{
+	int i, err, ret;
+
+	ret = 0;
+	for (i = 0; i < num; i++, array++) {
+		const char *label = array->label;
+		if (label[0] == '*')
+			label++;
+		err = gpio_request_one(array->gpio, array->flags, label);
+		if (err)
+			ret = err;
+		else {
+			err = gpio_export(array->gpio, array->label[0] != '*');
+		}
+	}
+	return ret;
+}
+
+static int __init laguna_pcie_init(void)
+{
+	if (!machine_is_gw2388())
+		return 0;
+
+	return cns3xxx_pcie_init();
+}
+subsys_initcall(laguna_pcie_init);
+
+static int __init laguna_model_setup(void)
+{
+	u32 __iomem *mem;
+	u32 reg;
+
+	if (!machine_is_gw2388())
+		return 0;
+
+	printk("Running on Gateworks Laguna %s\n", laguna_info.model);
+	cns3xxx_gpio_init( 0, 32, CNS3XXX_GPIOA_BASE_VIRT, IRQ_CNS3XXX_GPIOA,
+		NR_IRQS_CNS3XXX);
+	cns3xxx_gpio_init(32, 32, CNS3XXX_GPIOB_BASE_VIRT, IRQ_CNS3XXX_GPIOB,
+		NR_IRQS_CNS3XXX + 32);
+
+	if (strncmp(laguna_info.model, "GW", 2) == 0) {
+		if (laguna_info.config_bitmap & ETH0_LOAD)
+			laguna_net_data.ports |= BIT(0);
+		if (laguna_info.config_bitmap & ETH1_LOAD)
+			laguna_net_data.ports |= BIT(1);
+		if (laguna_info.config_bitmap & ETH2_LOAD)
+			laguna_net_data.ports |= BIT(2);
+		if (laguna_net_data.ports)
+			platform_device_register(&laguna_net_device);
+
+		if ((laguna_info.config_bitmap & SATA0_LOAD) ||
+		    (laguna_info.config_bitmap & SATA1_LOAD))
+			cns3xxx_ahci_init();
+
+		if (laguna_info.config_bitmap & (USB0_LOAD)) {
+			cns3xxx_pwr_power_up(1 << PM_PLL_HM_PD_CTRL_REG_OFFSET_PLL_USB);
+
+			/* DRVVBUS pins share with GPIOA */
+			mem = (void __iomem *)(CNS3XXX_MISC_BASE_VIRT + 0x0014);
+			reg = __raw_readl(mem);
+			reg |= 0x8;
+			__raw_writel(reg, mem);
+
+			/* Enable OTG */
+			mem = (void __iomem *)(CNS3XXX_MISC_BASE_VIRT + 0x0808);
+			reg = __raw_readl(mem);
+			reg &= ~(1 << 10);
+			__raw_writel(reg, mem);
+
+			platform_device_register(&cns3xxx_usb_otg_device);
+		}
+
+		if (laguna_info.config_bitmap & (USB1_LOAD)) {
+			platform_device_register(&cns3xxx_usb_ehci_device);
+			platform_device_register(&cns3xxx_usb_ohci_device);
+		}
+
+		if (laguna_info.config_bitmap & (SD_LOAD))
+			cns3xxx_sdhci_init();
+
+		if (laguna_info.config_bitmap & (UART0_LOAD))
+			laguna_uart.num_resources = 1;
+		if (laguna_info.config_bitmap & (UART1_LOAD))
+			laguna_uart.num_resources = 2;
+		if (laguna_info.config_bitmap & (UART2_LOAD))
+			laguna_uart.num_resources = 3;
+		platform_device_register(&laguna_uart);
+
+		if (laguna_info.config2_bitmap & (NOR_FLASH_LOAD)) {
+			switch (laguna_info.nor_flash_size) {
+				case 1:
+					laguna_nor_partitions[3].size = SZ_8M - SZ_256K - SZ_128K - SZ_2M;
+					laguna_nor_res.end = CNS3XXX_FLASH_BASE + SZ_8M - 1;
+				break;
+				case 2:
+					laguna_nor_partitions[3].size = SZ_16M - SZ_256K - SZ_128K - SZ_2M;
+					laguna_nor_res.end = CNS3XXX_FLASH_BASE + SZ_16M - 1;
+				break;
+				case 3:
+					laguna_nor_partitions[3].size = SZ_32M - SZ_256K - SZ_128K - SZ_2M;
+					laguna_nor_res.end = CNS3XXX_FLASH_BASE + SZ_32M - 1;
+				break;
+				case 4:
+					laguna_nor_partitions[3].size = SZ_64M - SZ_256K - SZ_128K - SZ_2M;
+					laguna_nor_res.end = CNS3XXX_FLASH_BASE + SZ_64M - 1;
+				break;
+				case 5:
+					laguna_nor_partitions[3].size = SZ_128M - SZ_256K - SZ_128K - SZ_2M;
+					laguna_nor_res.end = CNS3XXX_FLASH_BASE + SZ_128M - 1;
+				break;
+			}
+			platform_device_register(&laguna_nor_pdev);
+		}
+
+		if (laguna_info.config2_bitmap & (SPI_FLASH_LOAD)) {
+			switch (laguna_info.spi_flash_size) {
+				case 1:
+					laguna_spi_partitions[3].size = SZ_4M - SZ_2M;
+				break;
+				case 2:
+					laguna_spi_partitions[3].size = SZ_8M - SZ_2M;
+				break;
+				case 3:
+					laguna_spi_partitions[3].size = SZ_16M - SZ_2M;
+				break;
+				case 4:
+					laguna_spi_partitions[3].size = SZ_32M - SZ_2M;
+				break;
+				case 5:
+					laguna_spi_partitions[3].size = SZ_64M - SZ_2M;
+				break;
+			}
+			spi_register_board_info(ARRAY_AND_SIZE(laguna_spi_devices));
+		}
+
+		if ((laguna_info.config_bitmap & SPI0_LOAD) ||
+		    (laguna_info.config_bitmap & SPI1_LOAD))
+			platform_device_register(&laguna_spi_controller);
+
+		if (laguna_info.config2_bitmap & GPS_LOAD)
+			platform_device_register(&laguna_pps_device);
+
+		/*
+		 * Do any model specific setup not known by the bitmap by matching
+		 *  the first 6 characters of the model name
+		 */
+
+		if ( (strncmp(laguna_info.model, "GW2388", 6) == 0)
+		  || (strncmp(laguna_info.model, "GW2389", 6) == 0) )
+		{
+			// configure GPIO's
+			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2388));
+			// configure LED's
+			laguna_gpio_leds_data.num_leds = 2;
+		} else if (strncmp(laguna_info.model, "GW2387", 6) == 0) {
+			// configure GPIO's
+			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2387));
+			// configure LED's
+			laguna_gpio_leds_data.num_leds = 2;
+		} else if (strncmp(laguna_info.model, "GW2385", 6) == 0) {
+			// configure GPIO's
+			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2385));
+			// configure LED's
+			laguna_gpio_leds[0].gpio = 115;
+			laguna_gpio_leds[1].gpio = 12;
+			laguna_gpio_leds[1].name = "red";
+			laguna_gpio_leds[1].active_low = 0,
+			laguna_gpio_leds[2].gpio = 14;
+			laguna_gpio_leds[2].name = "green";
+			laguna_gpio_leds[2].active_low = 0,
+			laguna_gpio_leds[3].gpio = 15;
+			laguna_gpio_leds[3].name = "blue";
+			laguna_gpio_leds[3].active_low = 0,
+			laguna_gpio_leds_data.num_leds = 4;
+		} else if (strncmp(laguna_info.model, "GW2384", 6) == 0) {
+			// configure GPIO's
+			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2384));
+			// configure LED's
+			laguna_gpio_leds_data.num_leds = 1;
+		} else if (strncmp(laguna_info.model, "GW2383", 6) == 0) {
+			// configure GPIO's
+			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2383));
+			// configure LED's
+			laguna_gpio_leds[0].gpio = 107;
+			laguna_gpio_leds_data.num_leds = 1;
+		} else if (strncmp(laguna_info.model, "GW2382", 6) == 0) {
+			// configure GPIO's
+			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2382));
+			// configure LED's
+			laguna_gpio_leds[0].gpio = 107;
+			laguna_gpio_leds_data.num_leds = 1;
+		} else if (strncmp(laguna_info.model, "GW2380", 6) == 0) {
+			// configure GPIO's
+			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2380));
+			// configure LED's
+			laguna_gpio_leds[0].gpio = 107;
+			laguna_gpio_leds[1].gpio = 106;
+			laguna_gpio_leds_data.num_leds = 2;
+		} else if ( (strncmp(laguna_info.model, "GW2391", 6) == 0)
+			 || (strncmp(laguna_info.model, "GW2393", 6) == 0) )
+		{
+			// configure GPIO's
+			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2391));
+			// configure LED's
+			laguna_gpio_leds_data.num_leds = 2;
+		}
+		platform_device_register(&laguna_gpio_leds_device);
+	} else {
+		// Do some defaults here, not sure what yet
+	}
+	return 0;
+}
+late_initcall(laguna_model_setup);
+
+MACHINE_START(GW2388, "Gateworks Corporation Laguna Platform")
+	.smp		= smp_ops(cns3xxx_smp_ops),
+	.atag_offset	= 0x100,
+	.map_io		= laguna_map_io,
+	.init_irq	= cns3xxx_init_irq,
+	.init_time	= cns3xxx_timer_init,
+	.init_machine	= laguna_init,
+	.restart	= cns3xxx_restart,
+MACHINE_END
diff --git a/arch/arm/mach-cns3xxx/platsmp.c b/arch/arm/mach-cns3xxx/platsmp.c
new file mode 100644
index 00000000..cb81d1e7
--- /dev/null
+++ b/arch/arm/mach-cns3xxx/platsmp.c
@@ -0,0 +1,327 @@
+/*
+ *  linux/arch/arm/mach-cns3xxx/platsmp.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  Copyright 2012 Gateworks Corporation
+ *		   Chris Lang <clang@gateworks.com>
+ *         Tim Harvey <tharvey@gateworks.com>
+ *
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+
+#include <asm/cacheflush.h>
+#include <asm/smp_scu.h>
+#include <asm/unified.h>
+#include <asm/fiq.h>
+#include <mach/smp.h>
+#include "cns3xxx.h"
+
+static struct fiq_handler fh = {
+	.name = "cns3xxx-fiq"
+};
+
+struct fiq_req {
+	union {
+		struct {
+			const void *addr;
+			size_t size;
+		} map;
+		struct {
+			const void *addr;
+			size_t size;
+		} unmap;
+		struct {
+			const void *start;
+			const void *end;
+		} flush;
+	};
+	volatile uint flags;
+	void __iomem *reg;
+} ____cacheline_aligned;
+
+extern unsigned int fiq_number[2];
+
+DEFINE_PER_CPU(struct fiq_req, fiq_data);
+
+#define FIQ_ENABLED         0x80000000
+#define FIQ_GENERATE        0x00010000
+#define CNS3XXX_MAP_AREA    0x01000000
+#define CNS3XXX_UNMAP_AREA  0x02000000
+#define CNS3XXX_FLUSH_RANGE 0x03000000
+
+extern void cns3xxx_secondary_startup(void);
+extern unsigned char cns3xxx_fiq_start, cns3xxx_fiq_end;
+
+#define SCU_CPU_STATUS 0x08
+static void __iomem *scu_base;
+
+static inline void cns3xxx_set_fiq_regs(unsigned int cpu)
+{
+	struct pt_regs FIQ_regs;
+	struct fiq_req *fiq_req = &per_cpu(fiq_data, !cpu);
+
+	FIQ_regs.ARM_r8 = 0;
+	FIQ_regs.ARM_ip = (unsigned int)fiq_req;
+	FIQ_regs.ARM_sp = (int) MISC_FIQ_CPU(!cpu);
+	fiq_req->reg = MISC_FIQ_CPU(!cpu);
+
+	set_fiq_regs(&FIQ_regs);
+}
+
+static void __init cns3xxx_init_fiq(void)
+{
+	void *fiqhandler_start;
+	unsigned int fiqhandler_length;
+	int ret;
+
+	fiqhandler_start = &cns3xxx_fiq_start;
+	fiqhandler_length = &cns3xxx_fiq_end - &cns3xxx_fiq_start;
+
+	ret = claim_fiq(&fh);
+	if (ret)
+		return;
+
+	set_fiq_handler(fiqhandler_start, fiqhandler_length);
+}
+
+
+/*
+ * Write pen_release in a way that is guaranteed to be visible to all
+ * observers, irrespective of whether they're taking part in coherency
+ * or not.  This is necessary for the hotplug code to work reliably.
+ */
+static void write_pen_release(int val)
+{
+	pen_release = val;
+	smp_wmb();
+	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+static void cns3xxx_secondary_init(unsigned int cpu)
+{
+	/*
+	 * Setup Secondary Core FIQ regs
+	 */
+	cns3xxx_set_fiq_regs(1);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	write_pen_release(-1);
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+static int cns3xxx_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * Set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 *
+	 * Note that "pen_release" is the hardware CPU ID, whereas
+	 * "cpu" is Linux's internal ID.
+	 */
+	write_pen_release(cpu);
+
+	/*
+	 * Send the secondary CPU a soft interrupt, thereby causing
+	 * the boot monitor to read the system wide flags register,
+	 * and branch to the address found there.
+	 */
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));;
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+static void __init cns3xxx_smp_init_cpus(void)
+{
+	unsigned int i, ncores;
+	unsigned int status;
+
+	scu_base = (void __iomem *) CNS3XXX_TC11MP_SCU_BASE_VIRT;
+
+	/* for CNS3xxx SCU_CPU_STATUS must be examined instead of SCU_CONFIGURATION
+	 * used in scu_get_core_count
+	 */
+	status = __raw_readl(scu_base + SCU_CPU_STATUS);
+	for (i = 0; i < NR_CPUS+1; i++) {
+		if (((status >> (i*2)) & 0x3) == 0)
+			set_cpu_possible(i, true);
+		else
+			break;
+	}
+	ncores = i;
+}
+
+static void __init cns3xxx_smp_prepare_cpus(unsigned int max_cpus)
+{
+	/*
+	 * enable SCU
+	 */
+	scu_enable(scu_base);
+
+	/*
+	 * Write the address of secondary startup into the
+	 * system-wide flags register. The boot monitor waits
+	 * until it receives a soft interrupt, and then the
+	 * secondary CPU branches to this address.
+	 */
+	__raw_writel(virt_to_phys(cns3xxx_secondary_startup),
+			(void __iomem *)(CNS3XXX_MISC_BASE_VIRT + 0x0600));
+
+	/*
+	 * Setup FIQ's for main cpu
+	 */
+	cns3xxx_init_fiq();
+	cns3xxx_set_fiq_regs(0);
+}
+
+extern void v6_dma_map_area(const void *, size_t, int);
+extern void v6_dma_unmap_area(const void *, size_t, int);
+extern void v6_dma_flush_range(const void *, const void *);
+extern void v6_flush_kern_dcache_area(void *, size_t);
+
+void fiq_dma_map_area(const void *addr, size_t size, int dir)
+{
+	unsigned long flags;
+	struct fiq_req *req;
+
+	raw_local_irq_save(flags);
+	/* currently, not possible to take cpu0 down, so only check cpu1 */
+	if (!cpu_online(1)) {
+		raw_local_irq_restore(flags);
+		v6_dma_map_area(addr, size, dir);
+		return;
+	}
+
+	req = this_cpu_ptr(&fiq_data);
+	req->map.addr = addr;
+	req->map.size = size;
+	req->flags = dir | CNS3XXX_MAP_AREA;
+	smp_mb();
+
+	writel_relaxed(FIQ_GENERATE, req->reg);
+
+	v6_dma_map_area(addr, size, dir);
+	while (req->flags)
+		barrier();
+
+	raw_local_irq_restore(flags);
+}
+
+void fiq_dma_unmap_area(const void *addr, size_t size, int dir)
+{
+	unsigned long flags;
+	struct fiq_req *req;
+
+	raw_local_irq_save(flags);
+	/* currently, not possible to take cpu0 down, so only check cpu1 */
+	if (!cpu_online(1)) {
+		raw_local_irq_restore(flags);
+		v6_dma_unmap_area(addr, size, dir);
+		return;
+	}
+
+	req = this_cpu_ptr(&fiq_data);
+	req->unmap.addr = addr;
+	req->unmap.size = size;
+	req->flags = dir | CNS3XXX_UNMAP_AREA;
+	smp_mb();
+
+	writel_relaxed(FIQ_GENERATE, req->reg);
+
+	v6_dma_unmap_area(addr, size, dir);
+	while (req->flags)
+		barrier();
+
+	raw_local_irq_restore(flags);
+}
+
+void fiq_dma_flush_range(const void *start, const void *end)
+{
+	unsigned long flags;
+	struct fiq_req *req;
+
+	raw_local_irq_save(flags);
+	/* currently, not possible to take cpu0 down, so only check cpu1 */
+	if (!cpu_online(1)) {
+		raw_local_irq_restore(flags);
+		v6_dma_flush_range(start, end);
+		return;
+	}
+
+	req = this_cpu_ptr(&fiq_data);
+
+	req->flush.start = start;
+	req->flush.end = end;
+	req->flags = CNS3XXX_FLUSH_RANGE;
+	smp_mb();
+
+	writel_relaxed(FIQ_GENERATE, req->reg);
+
+	v6_dma_flush_range(start, end);
+
+	while (req->flags)
+		barrier();
+
+	raw_local_irq_restore(flags);
+}
+
+void fiq_flush_kern_dcache_area(void *addr, size_t size)
+{
+	fiq_dma_flush_range(addr, addr + size);
+}
+
+struct smp_operations cns3xxx_smp_ops __initdata = {
+	.smp_init_cpus      = cns3xxx_smp_init_cpus,
+	.smp_prepare_cpus   = cns3xxx_smp_prepare_cpus,
+	.smp_secondary_init = cns3xxx_secondary_init,
+	.smp_boot_secondary = cns3xxx_boot_secondary,
+};
diff --git a/drivers/i2c/busses/i2c-cns3xxx.c b/drivers/i2c/busses/i2c-cns3xxx.c
new file mode 100644
index 00000000..7acff37d
--- /dev/null
+++ b/drivers/i2c/busses/i2c-cns3xxx.c
@@ -0,0 +1,374 @@
+/*
+ * Cavium CNS3xxx I2C Host Controller
+ *
+ * Copyright 2010 Cavium Network
+ * Copyright 2012 Gateworks Corporation
+ *		  Chris Lang <clang@gateworks.com>
+ *		  Tim Harvey <tharvey@gateworks.com>
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <linux/wait.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+
+/*
+ * We need the memory map
+ */
+
+#define I2C_MEM_MAP_ADDR(x)         (i2c->base + x)
+#define I2C_MEM_MAP_VALUE(x)        (*((unsigned int volatile*)I2C_MEM_MAP_ADDR(x)))
+
+#define I2C_CONTROLLER_REG                    I2C_MEM_MAP_VALUE(0x00)
+#define I2C_TIME_OUT_REG                      I2C_MEM_MAP_VALUE(0x04)
+#define I2C_SLAVE_ADDRESS_REG                 I2C_MEM_MAP_VALUE(0x08)
+#define I2C_WRITE_DATA_REG                    I2C_MEM_MAP_VALUE(0x0C)
+#define I2C_READ_DATA_REG                     I2C_MEM_MAP_VALUE(0x10)
+#define I2C_INTERRUPT_STATUS_REG              I2C_MEM_MAP_VALUE(0x14)
+#define I2C_INTERRUPT_ENABLE_REG              I2C_MEM_MAP_VALUE(0x18)
+#define I2C_TWI_OUT_DLY_REG			         			I2C_MEM_MAP_VALUE(0x1C)
+
+#define I2C_BUS_ERROR_FLAG     (0x1)
+#define I2C_ACTION_DONE_FLAG   (0x2)
+
+#define CNS3xxx_I2C_ENABLE()          (I2C_CONTROLLER_REG) |= ((unsigned int)0x1 << 31)
+#define CNS3xxx_I2C_DISABLE()         (I2C_CONTROLLER_REG) &= ~((unsigned int)0x1 << 31)
+#define CNS3xxx_I2C_ENABLE_INTR()     (I2C_INTERRUPT_ENABLE_REG) |= 0x03
+#define CNS3xxx_I2C_DISABLE_INTR()    (I2C_INTERRUPT_ENABLE_REG) &= 0xfc
+
+#define TWI_TIMEOUT         (10*HZ)
+#define I2C_100KHZ          100000
+#define I2C_200KHZ          200000
+#define I2C_300KHZ          300000
+#define I2C_400KHZ          400000
+
+#define CNS3xxx_I2C_CLK     I2C_100KHZ
+
+#define STATE_DONE		1
+#define STATE_ERROR		2
+
+struct cns3xxx_i2c {
+	struct device		*dev;
+	void __iomem		*base;		/* virtual */
+	wait_queue_head_t	wait;
+	struct i2c_adapter	adap;
+	struct i2c_msg		*msg;
+	u8			state;		/* see STATE_ */
+	u8			error;		/* see TWI_STATUS register */
+	int			rd_wr_len;
+	u8			*buf;
+};
+
+static u32 cns3xxx_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static int
+cns3xxx_i2c_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg)
+{
+	struct cns3xxx_i2c *i2c = i2c_get_adapdata(adap);
+	int i, j;
+	u8 buf[1] = { 0 };
+
+	if (msg->len == 0) {
+		/*
+		 *	We are probably doing a probe for a device here,
+		 *	so set the length to one, and data to 0
+		 */
+		msg->len = 1;
+		i2c->buf = buf;
+	} else {
+		i2c->buf = msg->buf;
+	}
+
+	if (msg->flags & I2C_M_TEN) {
+		printk
+			("%s:%d: Presently the driver does not handle extended addressing\n",
+				__FUNCTION__, __LINE__);
+		return -EINVAL;
+	}
+	i2c->msg = msg;
+
+	for (i = 0; i < msg->len; i++) {
+		if (msg->len - i >= 4)
+			i2c->rd_wr_len = 3;
+		else
+			i2c->rd_wr_len = msg->len - i - 1;
+
+		// Set Data Width	and TWI_EN
+		I2C_CONTROLLER_REG = 0x80000000 | (i2c->rd_wr_len << 2) | (i2c->rd_wr_len);
+
+		// Clear Write Reg
+		I2C_WRITE_DATA_REG = 0;
+
+		// Set the slave address
+		I2C_SLAVE_ADDRESS_REG = (msg->addr << 1);
+
+		// Are we Writing
+		if (!(msg->flags & I2C_M_RD)) {
+			I2C_CONTROLLER_REG |= (1 << 4);
+			if (i != 0) {
+				/*
+				 * We need to set the address in the first byte.
+				 * The base address is going to be in buf[0] and then
+				 * it needs to be incremented by i - 1.
+				 */
+				i2c->buf--;
+				*i2c->buf = buf[0] + i - 1;
+
+				if (i2c->rd_wr_len < 3) {
+					i += i2c->rd_wr_len;
+					i2c->rd_wr_len++;
+					I2C_CONTROLLER_REG = 0x80000000 | (1 << 4) | (i2c->rd_wr_len << 2) | (i2c->rd_wr_len);
+				} else {
+					i += i2c->rd_wr_len - 1;
+				}
+			} else {
+				i += i2c->rd_wr_len;
+				buf[0] = *i2c->buf;
+			}
+			for (j = 0; j <= i2c->rd_wr_len; j++) {
+				I2C_WRITE_DATA_REG |= ((*i2c->buf++) << (8 * j));
+			}
+		} else {
+			i += i2c->rd_wr_len;
+		}
+
+		// Start the Transfer
+		i2c->state = 0;		// Clear out the State
+		i2c->error = 0;
+		I2C_CONTROLLER_REG |= (1 << 6);
+
+		if (wait_event_timeout(i2c->wait, (i2c->state == STATE_ERROR) ||
+				(i2c->state == STATE_DONE), TWI_TIMEOUT)) {
+			if (i2c->state == STATE_ERROR) {
+				dev_dbg(i2c->dev, "controller error: 0x%2x", i2c->error);
+				return -EAGAIN; // try again
+			}
+		} else {
+			dev_err(i2c->dev, "controller timed out "
+				"waiting for start condition to finish\n");
+			return -ETIMEDOUT;
+		}
+	}
+	return 0;
+}
+
+static int
+cns3xxx_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
+{
+	int i;
+	int ret;
+	for (i = 0; i < num; i++)
+	{
+		ret = cns3xxx_i2c_xfer_msg(adap, &msgs[i]);
+		if (ret < 0) {
+			return ret;
+		}
+	}
+	return num;
+}
+
+
+static struct i2c_algorithm cns3xxx_i2c_algo = {
+	.master_xfer = cns3xxx_i2c_xfer,
+	.functionality = cns3xxx_i2c_func,
+};
+
+static struct i2c_adapter cns3xxx_i2c_adapter = {
+	.owner = THIS_MODULE,
+	.algo = &cns3xxx_i2c_algo,
+	.algo_data = NULL,
+	.nr = 0,
+	.name = "CNS3xxx I2C 0",
+	.retries = 5,
+};
+
+static void cns3xxx_i2c_adapter_init(struct cns3xxx_i2c *i2c)
+{
+	struct clk *clk;
+
+	clk = devm_clk_get(i2c->dev, "cpu");
+	if (WARN_ON(!clk))
+		return;
+
+	/* Disable the I2C */
+	I2C_CONTROLLER_REG = 0;	/* Disabled the I2C */
+
+	/* Check the Reg Dump when testing */
+	I2C_TIME_OUT_REG =
+	    (((((clk_get_rate(clk) / (2 * CNS3xxx_I2C_CLK)) -
+		1) & 0x3FF) << 8) | (1 << 7) | 0x7F);
+	I2C_TWI_OUT_DLY_REG |= 0x3;
+
+	/* Enable The Interrupt */
+	CNS3xxx_I2C_ENABLE_INTR();
+
+	/* Clear Interrupt Status (0x2 | 0x1) */
+	I2C_INTERRUPT_STATUS_REG |= (I2C_ACTION_DONE_FLAG | I2C_BUS_ERROR_FLAG);
+
+	/* Enable the I2C Controller */
+	CNS3xxx_I2C_ENABLE();
+}
+
+static irqreturn_t cns3xxx_i2c_isr(int irq, void *dev_id)
+{
+	struct cns3xxx_i2c *i2c = dev_id;
+	int i;
+	uint32_t stat = I2C_INTERRUPT_STATUS_REG;
+
+	/* Clear Interrupt */
+	I2C_INTERRUPT_STATUS_REG |= 0x1;
+
+	if (stat & I2C_BUS_ERROR_FLAG) {
+		i2c->state = STATE_ERROR;
+		i2c->error = (I2C_INTERRUPT_STATUS_REG & 0xff00)>>8;
+	} else {
+		if (i2c->msg->flags & I2C_M_RD) {
+			for (i = 0; i <= i2c->rd_wr_len; i++)
+			{
+				*i2c->buf++ = ((I2C_READ_DATA_REG >> (8 * i)) & 0xff);
+			}
+		}
+		i2c->state = STATE_DONE;
+	}
+	wake_up(&i2c->wait);
+	return IRQ_HANDLED;
+}
+
+static int cns3xxx_i2c_probe(struct platform_device *pdev)
+{
+	struct cns3xxx_i2c *i2c;
+	struct resource *res, *res2;
+	int ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		printk("%s: IORESOURCE_MEM not defined \n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res2) {
+		printk("%s: IORESOURCE_IRQ not defined \n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	i2c = kzalloc(sizeof(*i2c), GFP_KERNEL);
+	if (!i2c)
+		return -ENOMEM;
+
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+				pdev->name)) {
+		dev_err(&pdev->dev, "Memory region busy\n");
+		ret = -EBUSY;
+		goto request_mem_failed;
+	}
+
+	i2c->dev = &pdev->dev;
+	i2c->base = ioremap(res->start, res->end - res->start + 1);
+	if (!i2c->base) {
+		dev_err(&pdev->dev, "Unable to map registers\n");
+		ret = -EIO;
+		goto map_failed;
+	}
+
+	cns3xxx_i2c_adapter_init(i2c);
+
+	init_waitqueue_head(&i2c->wait);
+	ret = request_irq(res2->start, cns3xxx_i2c_isr, 0, pdev->name, i2c);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot claim IRQ\n");
+		goto request_irq_failed;
+	}
+
+	platform_set_drvdata(pdev, i2c);
+	i2c->adap = cns3xxx_i2c_adapter;
+	i2c_set_adapdata(&i2c->adap, i2c);
+	i2c->adap.dev.parent = &pdev->dev;
+
+	/* add i2c adapter to i2c tree */
+	ret = i2c_add_numbered_adapter(&i2c->adap);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add adapter\n");
+		goto add_adapter_failed;
+	}
+
+	return 0;
+
+      add_adapter_failed:
+	free_irq(res2->start, i2c);
+      request_irq_failed:
+	iounmap(i2c->base);
+      map_failed:
+	release_mem_region(res->start, res->end - res->start + 1);
+      request_mem_failed:
+	kfree(i2c);
+
+	return ret;
+}
+
+static int cns3xxx_i2c_remove(struct platform_device *pdev)
+{
+	struct cns3xxx_i2c *i2c = platform_get_drvdata(pdev);
+	struct resource *res;
+
+	/* disable i2c logic */
+	CNS3xxx_I2C_DISABLE_INTR();
+	CNS3xxx_I2C_DISABLE();
+	/* remove adapter & data */
+	i2c_del_adapter(&i2c->adap);
+	platform_set_drvdata(pdev, NULL);
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res)
+		free_irq(res->start, i2c);
+
+	iounmap(i2c->base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, res->end - res->start + 1);
+
+	kfree(i2c);
+
+	return 0;
+}
+
+static struct platform_driver cns3xxx_i2c_driver = {
+	.probe = cns3xxx_i2c_probe,
+	.remove = cns3xxx_i2c_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "cns3xxx-i2c",
+	},
+};
+
+static int __init cns3xxx_i2c_init(void)
+{
+	return platform_driver_register(&cns3xxx_i2c_driver);
+}
+
+static void __exit cns3xxx_i2c_exit(void)
+{
+	platform_driver_unregister(&cns3xxx_i2c_driver);
+}
+
+module_init(cns3xxx_i2c_init);
+module_exit(cns3xxx_i2c_exit);
+
+MODULE_AUTHOR("Cavium Networks");
+MODULE_DESCRIPTION("Cavium CNS3XXX I2C Controller");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/cavium/Kconfig b/drivers/net/ethernet/cavium/Kconfig
index 8fb84e69..79eebe28 100644
--- a/drivers/net/ethernet/cavium/Kconfig
+++ b/drivers/net/ethernet/cavium/Kconfig
@@ -1,56 +1,24 @@
-#
-# Cavium ethernet device configuration
-#
-
 config NET_VENDOR_CAVIUM
-	bool "Cavium ethernet drivers"
-	depends on PCI
+	bool "Cavium devices"
 	default y
+	depends on ARCH_CNS3XXX
 	---help---
-	  Select this option if you want enable Cavium network support.
+	  If you have a network (Ethernet) chipset belonging to this class,
+	  say Y.
 
-	  If you have a Cavium SoC or network adapter, say Y.
+	  Note that the answer to this question does not directly affect
+	  the kernel: saying N will just case the configurator to skip all
+	  the questions regarding AMD chipsets. If you say Y, you will be asked
+	  for your specific chipset/driver in the following questions.
 
 if NET_VENDOR_CAVIUM
 
-config THUNDER_NIC_PF
-	tristate "Thunder Physical function driver"
-	depends on 64BIT
-	select THUNDER_NIC_BGX
-	---help---
-	  This driver supports Thunder's NIC physical function.
-	  The NIC provides the controller and DMA engines to
-	  move network traffic to/from the memory. The NIC
-	  works closely with TNS, BGX and SerDes to implement the
-	  functions replacing and virtualizing those of a typical
-	  standalone PCIe NIC chip.
-
-config THUNDER_NIC_VF
-	tristate "Thunder Virtual function driver"
-	depends on 64BIT
-	---help---
-	  This driver supports Thunder's NIC virtual function
-
-config	THUNDER_NIC_BGX
-	tristate "Thunder MAC interface driver (BGX)"
-	depends on 64BIT
+config CNS3XXX_ETH
+	tristate "Cavium CNS3xxx Ethernet support"
+	depends on ARCH_CNS3XXX
 	select PHYLIB
-	select MDIO_OCTEON
-	---help---
-	  This driver supports programming and controlling of MAC
-	  interface from NIC physical function driver.
-
-config LIQUIDIO
-	tristate "Cavium LiquidIO support"
-	depends on 64BIT
-	select PTP_1588_CLOCK
-	select FW_LOADER
-	select LIBCRC32C
-	---help---
-	  This driver supports Cavium LiquidIO Intelligent Server Adapters
-	  based on CN66XX and CN68XX chips.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called liquidio.  This is recommended.
+	help
+	  Say Y here if you want to use built-in Ethernet ports
+	  on CNS3XXX processor.
 
-endif # NET_VENDOR_CAVIUM
+endif
diff --git a/drivers/net/ethernet/cavium/Makefile b/drivers/net/ethernet/cavium/Makefile
index d22f886a..badd2404 100644
--- a/drivers/net/ethernet/cavium/Makefile
+++ b/drivers/net/ethernet/cavium/Makefile
@@ -1,5 +1,5 @@
 #
 # Makefile for the Cavium ethernet device drivers.
 #
-obj-$(CONFIG_NET_VENDOR_CAVIUM) += thunder/
-obj-$(CONFIG_NET_VENDOR_CAVIUM) += liquidio/
+
+obj-$(CONFIG_CNS3XXX_ETH) += cns3xxx_eth.o
diff --git a/drivers/net/ethernet/cavium/cns3xxx_eth.c b/drivers/net/ethernet/cavium/cns3xxx_eth.c
new file mode 100644
index 00000000..51b01876
--- /dev/null
+++ b/drivers/net/ethernet/cavium/cns3xxx_eth.c
@@ -0,0 +1,1340 @@
+/*
+ * Cavium CNS3xxx Gigabit driver for Linux
+ *
+ * Copyright 2011 Gateworks Corporation
+ *		  Chris Lang <clang@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/cns3xxx.h>
+#include <linux/skbuff.h>
+
+#define DRV_NAME "cns3xxx_eth"
+
+#define RX_DESCS 256
+#define TX_DESCS 128
+#define TX_DESC_RESERVE	20
+
+#define RX_POOL_ALLOC_SIZE (sizeof(struct rx_desc) * RX_DESCS)
+#define TX_POOL_ALLOC_SIZE (sizeof(struct tx_desc) * TX_DESCS)
+#define REGS_SIZE 336
+
+#define RX_BUFFER_ALIGN 64
+#define RX_BUFFER_ALIGN_MASK (~(RX_BUFFER_ALIGN - 1))
+
+#define SKB_HEAD_ALIGN (((PAGE_SIZE - NET_SKB_PAD) % RX_BUFFER_ALIGN) + NET_SKB_PAD + NET_IP_ALIGN)
+#define RX_SEGMENT_ALLOC_SIZE 2048
+#define RX_SEGMENT_BUFSIZE (SKB_WITH_OVERHEAD(RX_SEGMENT_ALLOC_SIZE))
+#define RX_SEGMENT_MRU (((RX_SEGMENT_BUFSIZE - SKB_HEAD_ALIGN) & RX_BUFFER_ALIGN_MASK) - NET_IP_ALIGN)
+#define MAX_MTU	9500
+
+#define NAPI_WEIGHT 64
+
+/* MDIO Defines */
+#define MDIO_CMD_COMPLETE 0x00008000
+#define MDIO_WRITE_COMMAND 0x00002000
+#define MDIO_READ_COMMAND 0x00004000
+#define MDIO_REG_OFFSET 8
+#define MDIO_VALUE_OFFSET 16
+
+/* Descritor Defines */
+#define END_OF_RING 0x40000000
+#define FIRST_SEGMENT 0x20000000
+#define LAST_SEGMENT 0x10000000
+#define FORCE_ROUTE 0x04000000
+#define UDP_CHECKSUM 0x00020000
+#define TCP_CHECKSUM 0x00010000
+
+/* Port Config Defines */
+#define PORT_BP_ENABLE 0x00020000
+#define PORT_DISABLE 0x00040000
+#define PORT_LEARN_DIS 0x00080000
+#define PORT_BLOCK_STATE 0x00100000
+#define PORT_BLOCK_MODE 0x00200000
+
+#define PROMISC_OFFSET 29
+
+/* Global Config Defines */
+#define UNKNOWN_VLAN_TO_CPU 0x02000000
+#define ACCEPT_CRC_PACKET 0x00200000
+#define CRC_STRIPPING 0x00100000
+
+/* VLAN Config Defines */
+#define NIC_MODE 0x00008000
+#define VLAN_UNAWARE 0x00000001
+
+/* DMA AUTO Poll Defines */
+#define TS_POLL_EN 0x00000020
+#define TS_SUSPEND 0x00000010
+#define FS_POLL_EN 0x00000002
+#define FS_SUSPEND 0x00000001
+
+/* DMA Ring Control Defines */
+#define QUEUE_THRESHOLD 0x000000f0
+#define CLR_FS_STATE 0x80000000
+
+/* Interrupt Status Defines */
+#define MAC0_STATUS_CHANGE 0x00004000
+#define MAC1_STATUS_CHANGE 0x00008000
+#define MAC2_STATUS_CHANGE 0x00010000
+#define MAC0_RX_ERROR 0x00100000
+#define MAC1_RX_ERROR 0x00200000
+#define MAC2_RX_ERROR 0x00400000
+
+struct tx_desc
+{
+	u32 sdp; /* segment data pointer */
+
+	union {
+		struct {
+			u32 sdl:16; /* segment data length */
+			u32 tco:1;
+			u32 uco:1;
+			u32 ico:1;
+			u32 rsv_1:3; /* reserve */
+			u32 pri:3;
+			u32 fp:1; /* force priority */
+			u32 fr:1;
+			u32 interrupt:1;
+			u32 lsd:1;
+			u32 fsd:1;
+			u32 eor:1;
+			u32 cown:1;
+		};
+		u32 config0;
+	};
+
+	union {
+		struct {
+			u32 ctv:1;
+			u32 stv:1;
+			u32 sid:4;
+			u32 inss:1;
+			u32 dels:1;
+			u32 rsv_2:9;
+			u32 pmap:5;
+			u32 mark:3;
+			u32 ewan:1;
+			u32 fewan:1;
+			u32 rsv_3:5;
+		};
+		u32 config1;
+	};
+
+	union {
+		struct {
+			u32 c_vid:12;
+			u32 c_cfs:1;
+			u32 c_pri:3;
+			u32 s_vid:12;
+			u32 s_dei:1;
+			u32 s_pri:3;
+		};
+		u32 config2;
+	};
+
+	u8 alignment[16]; /* for 32 byte */
+};
+
+struct rx_desc
+{
+	u32 sdp; /* segment data pointer */
+
+	union {
+		struct {
+			u32 sdl:16; /* segment data length */
+			u32 l4f:1;
+			u32 ipf:1;
+			u32 prot:4;
+			u32 hr:6;
+			u32 lsd:1;
+			u32 fsd:1;
+			u32 eor:1;
+			u32 cown:1;
+		};
+		u32 config0;
+	};
+
+	union {
+		struct {
+			u32 ctv:1;
+			u32 stv:1;
+			u32 unv:1;
+			u32 iwan:1;
+			u32 exdv:1;
+			u32 e_wan:1;
+			u32 rsv_1:2;
+			u32 sp:3;
+			u32 crc_err:1;
+			u32 un_eth:1;
+			u32 tc:2;
+			u32 rsv_2:1;
+			u32 ip_offset:5;
+			u32 rsv_3:11;
+		};
+		u32 config1;
+	};
+
+	union {
+		struct {
+			u32 c_vid:12;
+			u32 c_cfs:1;
+			u32 c_pri:3;
+			u32 s_vid:12;
+			u32 s_dei:1;
+			u32 s_pri:3;
+		};
+		u32 config2;
+	};
+
+	u8 alignment[16]; /* for 32 byte alignment */
+};
+
+
+struct switch_regs {
+	u32 phy_control;
+	u32 phy_auto_addr;
+	u32 mac_glob_cfg;
+	u32 mac_cfg[4];
+	u32 mac_pri_ctrl[5], __res;
+	u32 etype[2];
+	u32 udp_range[4];
+	u32 prio_etype_udp;
+	u32 prio_ipdscp[8];
+	u32 tc_ctrl;
+	u32 rate_ctrl;
+	u32 fc_glob_thrs;
+	u32 fc_port_thrs;
+	u32 mc_fc_glob_thrs;
+	u32 dc_glob_thrs;
+	u32 arl_vlan_cmd;
+	u32 arl_ctrl[3];
+	u32 vlan_cfg;
+	u32 pvid[2];
+	u32 vlan_ctrl[3];
+	u32 session_id[8];
+	u32 intr_stat;
+	u32 intr_mask;
+	u32 sram_test;
+	u32 mem_queue;
+	u32 farl_ctrl;
+	u32 fc_input_thrs, __res1[2];
+	u32 clk_skew_ctrl;
+	u32 mac_glob_cfg_ext, __res2[2];
+	u32 dma_ring_ctrl;
+	u32 dma_auto_poll_cfg;
+	u32 delay_intr_cfg, __res3;
+	u32 ts_dma_ctrl0;
+	u32 ts_desc_ptr0;
+	u32 ts_desc_base_addr0, __res4;
+	u32 fs_dma_ctrl0;
+	u32 fs_desc_ptr0;
+	u32 fs_desc_base_addr0, __res5;
+	u32 ts_dma_ctrl1;
+	u32 ts_desc_ptr1;
+	u32 ts_desc_base_addr1, __res6;
+	u32 fs_dma_ctrl1;
+	u32 fs_desc_ptr1;
+	u32 fs_desc_base_addr1;
+	u32 __res7[109];
+	u32 mac_counter0[13];
+};
+
+struct _tx_ring {
+	struct tx_desc *desc;
+	dma_addr_t phys_addr;
+	struct tx_desc *cur_addr;
+	struct sk_buff *buff_tab[TX_DESCS];
+	unsigned int phys_tab[TX_DESCS];
+	u32 free_index;
+	u32 count_index;
+	u32 cur_index;
+	int num_used;
+	int num_count;
+	bool stopped;
+};
+
+struct _rx_ring {
+	struct rx_desc *desc;
+	dma_addr_t phys_addr;
+	struct rx_desc *cur_addr;
+	void *buff_tab[RX_DESCS];
+	unsigned int phys_tab[RX_DESCS];
+	u32 cur_index;
+	u32 alloc_index;
+	int alloc_count;
+};
+
+struct sw {
+	struct switch_regs __iomem *regs;
+	struct napi_struct napi;
+	struct cns3xxx_plat_info *plat;
+	struct _tx_ring tx_ring;
+	struct _rx_ring rx_ring;
+	struct sk_buff *frag_first;
+	struct sk_buff *frag_last;
+	struct device *dev;
+	int rx_irq;
+	int stat_irq;
+};
+
+struct port {
+	struct net_device *netdev;
+	struct phy_device *phydev;
+	struct sw *sw;
+	int id;			/* logical port ID */
+	int speed, duplex;
+};
+
+static spinlock_t mdio_lock;
+static DEFINE_SPINLOCK(tx_lock);
+static struct switch_regs __iomem *mdio_regs; /* mdio command and status only */
+struct mii_bus *mdio_bus;
+static int ports_open;
+static struct port *switch_port_tab[4];
+struct net_device *napi_dev;
+
+static int cns3xxx_mdio_cmd(struct mii_bus *bus, int phy_id, int location,
+			   int write, u16 cmd)
+{
+	int cycles = 0;
+	u32 temp = 0;
+
+	temp = __raw_readl(&mdio_regs->phy_control);
+	temp |= MDIO_CMD_COMPLETE;
+	__raw_writel(temp, &mdio_regs->phy_control);
+	udelay(10);
+
+	if (write) {
+		temp = (cmd << MDIO_VALUE_OFFSET);
+		temp |= MDIO_WRITE_COMMAND;
+	} else {
+		temp = MDIO_READ_COMMAND;
+	}
+	temp |= ((location & 0x1f) << MDIO_REG_OFFSET);
+	temp |= (phy_id & 0x1f);
+
+	__raw_writel(temp, &mdio_regs->phy_control);
+
+	while (((__raw_readl(&mdio_regs->phy_control) & MDIO_CMD_COMPLETE) == 0)
+			&& cycles < 5000) {
+		udelay(1);
+		cycles++;
+	}
+
+	if (cycles == 5000) {
+		printk(KERN_ERR "%s #%i: MII transaction failed\n", bus->name,
+		       phy_id);
+		return -1;
+	}
+
+	temp = __raw_readl(&mdio_regs->phy_control);
+	temp |= MDIO_CMD_COMPLETE;
+	__raw_writel(temp, &mdio_regs->phy_control);
+
+	if (write)
+		return 0;
+
+	return ((temp >> MDIO_VALUE_OFFSET) & 0xFFFF);
+}
+
+static int cns3xxx_mdio_read(struct mii_bus *bus, int phy_id, int location)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&mdio_lock, flags);
+	ret = cns3xxx_mdio_cmd(bus, phy_id, location, 0, 0);
+	spin_unlock_irqrestore(&mdio_lock, flags);
+	return ret;
+}
+
+static int cns3xxx_mdio_write(struct mii_bus *bus, int phy_id, int location,
+			     u16 val)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&mdio_lock, flags);
+	ret = cns3xxx_mdio_cmd(bus, phy_id, location, 1, val);
+	spin_unlock_irqrestore(&mdio_lock, flags);
+	return ret;
+}
+
+static int cns3xxx_mdio_register(void __iomem *base)
+{
+	int err;
+
+	if (!(mdio_bus = mdiobus_alloc()))
+		return -ENOMEM;
+
+	mdio_regs = base;
+
+	spin_lock_init(&mdio_lock);
+	mdio_bus->name = "CNS3xxx MII Bus";
+	mdio_bus->read = &cns3xxx_mdio_read;
+	mdio_bus->write = &cns3xxx_mdio_write;
+	strcpy(mdio_bus->id, "0");
+
+	if ((err = mdiobus_register(mdio_bus)))
+		mdiobus_free(mdio_bus);
+	return err;
+}
+
+static void cns3xxx_mdio_remove(void)
+{
+	mdiobus_unregister(mdio_bus);
+	mdiobus_free(mdio_bus);
+}
+
+static void enable_tx_dma(struct sw *sw)
+{
+	__raw_writel(0x1, &sw->regs->ts_dma_ctrl0);
+}
+
+static void enable_rx_dma(struct sw *sw)
+{
+	__raw_writel(0x1, &sw->regs->fs_dma_ctrl0);
+}
+
+static void cns3xxx_adjust_link(struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	struct phy_device *phydev = port->phydev;
+
+	if (!phydev->link) {
+		if (port->speed) {
+			port->speed = 0;
+			printk(KERN_INFO "%s: link down\n", dev->name);
+		}
+		return;
+	}
+
+	if (port->speed == phydev->speed && port->duplex == phydev->duplex)
+		return;
+
+	port->speed = phydev->speed;
+	port->duplex = phydev->duplex;
+
+	printk(KERN_INFO "%s: link up, speed %u Mb/s, %s duplex\n",
+	       dev->name, port->speed, port->duplex ? "full" : "half");
+}
+
+static void eth_schedule_poll(struct sw *sw)
+{
+	if (unlikely(!napi_schedule_prep(&sw->napi)))
+		return;
+
+	disable_irq_nosync(sw->rx_irq);
+	__napi_schedule(&sw->napi);
+}
+
+irqreturn_t eth_rx_irq(int irq, void *pdev)
+{
+	struct net_device *dev = pdev;
+	struct sw *sw = netdev_priv(dev);
+	eth_schedule_poll(sw);
+	return (IRQ_HANDLED);
+}
+
+irqreturn_t eth_stat_irq(int irq, void *pdev)
+{
+	struct net_device *dev = pdev;
+	struct sw *sw = netdev_priv(dev);
+	u32 cfg;
+	u32 stat = __raw_readl(&sw->regs->intr_stat);
+	__raw_writel(0xffffffff, &sw->regs->intr_stat);
+
+	if (stat & MAC2_RX_ERROR)
+		switch_port_tab[3]->netdev->stats.rx_dropped++;
+	if (stat & MAC1_RX_ERROR)
+		switch_port_tab[1]->netdev->stats.rx_dropped++;
+	if (stat & MAC0_RX_ERROR)
+		switch_port_tab[0]->netdev->stats.rx_dropped++;
+
+	if (stat & MAC0_STATUS_CHANGE) {
+		cfg = __raw_readl(&sw->regs->mac_cfg[0]);
+		switch_port_tab[0]->phydev->link = (cfg & 0x1);
+		switch_port_tab[0]->phydev->duplex = ((cfg >> 4) & 0x1);
+		if (((cfg >> 2) & 0x3) == 2)
+			switch_port_tab[0]->phydev->speed = 1000;
+		else if (((cfg >> 2) & 0x3) == 1)
+			switch_port_tab[0]->phydev->speed = 100;
+		else
+			switch_port_tab[0]->phydev->speed = 10;
+		cns3xxx_adjust_link(switch_port_tab[0]->netdev);
+	}
+
+	if (stat & MAC1_STATUS_CHANGE) {
+		cfg = __raw_readl(&sw->regs->mac_cfg[1]);
+		switch_port_tab[1]->phydev->link = (cfg & 0x1);
+		switch_port_tab[1]->phydev->duplex = ((cfg >> 4) & 0x1);
+		if (((cfg >> 2) & 0x3) == 2)
+			switch_port_tab[1]->phydev->speed = 1000;
+		else if (((cfg >> 2) & 0x3) == 1)
+			switch_port_tab[1]->phydev->speed = 100;
+		else
+			switch_port_tab[1]->phydev->speed = 10;
+		cns3xxx_adjust_link(switch_port_tab[1]->netdev);
+	}
+
+	if (stat & MAC2_STATUS_CHANGE) {
+		cfg = __raw_readl(&sw->regs->mac_cfg[3]);
+		switch_port_tab[3]->phydev->link = (cfg & 0x1);
+		switch_port_tab[3]->phydev->duplex = ((cfg >> 4) & 0x1);
+		if (((cfg >> 2) & 0x3) == 2)
+			switch_port_tab[3]->phydev->speed = 1000;
+		else if (((cfg >> 2) & 0x3) == 1)
+			switch_port_tab[3]->phydev->speed = 100;
+		else
+			switch_port_tab[3]->phydev->speed = 10;
+		cns3xxx_adjust_link(switch_port_tab[3]->netdev);
+	}
+
+	return (IRQ_HANDLED);
+}
+
+
+static void cns3xxx_alloc_rx_buf(struct sw *sw, int received)
+{
+	struct _rx_ring *rx_ring = &sw->rx_ring;
+	unsigned int i = rx_ring->alloc_index;
+	struct rx_desc *desc = &(rx_ring)->desc[i];
+	void *buf;
+	unsigned int phys;
+
+	for (received += rx_ring->alloc_count; received > 0; received--) {
+		buf = napi_alloc_frag(RX_SEGMENT_ALLOC_SIZE);
+		if (!buf)
+			break;
+
+		phys = dma_map_single(sw->dev, buf + SKB_HEAD_ALIGN,
+				      RX_SEGMENT_MRU, DMA_FROM_DEVICE);
+		if (dma_mapping_error(sw->dev, phys)) {
+			skb_free_frag(buf);
+			break;
+		}
+
+		desc->sdl = RX_SEGMENT_MRU;
+		desc->sdp = phys;
+
+		wmb();
+
+		/* put the new buffer on RX-free queue */
+		rx_ring->buff_tab[i] = buf;
+		rx_ring->phys_tab[i] = phys;
+		if (i == RX_DESCS - 1) {
+			i = 0;
+			desc->config0 = END_OF_RING | FIRST_SEGMENT |
+					LAST_SEGMENT | RX_SEGMENT_MRU;
+			desc = &(rx_ring)->desc[i];
+		} else {
+			desc->config0 = FIRST_SEGMENT | LAST_SEGMENT |
+					RX_SEGMENT_MRU;
+			i++;
+			desc++;
+		}
+	}
+
+	rx_ring->alloc_count = received;
+	rx_ring->alloc_index = i;
+}
+
+static void eth_check_num_used(struct _tx_ring *tx_ring)
+{
+	bool stop = false;
+	int i;
+
+	if (tx_ring->num_used >= TX_DESCS - TX_DESC_RESERVE)
+		stop = true;
+
+	if (tx_ring->stopped == stop)
+		return;
+
+	tx_ring->stopped = stop;
+	for (i = 0; i < 4; i++) {
+		struct port *port = switch_port_tab[i];
+		struct net_device *dev;
+
+		if (!port)
+			continue;
+
+		dev = port->netdev;
+		if (stop)
+			netif_stop_queue(dev);
+		else
+			netif_wake_queue(dev);
+	}
+}
+
+static void eth_complete_tx(struct sw *sw)
+{
+	struct _tx_ring *tx_ring = &sw->tx_ring;
+	struct tx_desc *desc;
+	int i;
+	int index;
+	int num_used = tx_ring->num_used;
+	struct sk_buff *skb;
+
+	index = tx_ring->free_index;
+	desc = &(tx_ring)->desc[index];
+	for (i = 0; i < num_used; i++) {
+		if (desc->cown) {
+			skb = tx_ring->buff_tab[index];
+			tx_ring->buff_tab[index] = 0;
+			if (skb)
+				dev_kfree_skb_any(skb);
+			dma_unmap_single(sw->dev, tx_ring->phys_tab[index],
+				desc->sdl, DMA_TO_DEVICE);
+			if (++index == TX_DESCS) {
+				index = 0;
+				desc = &(tx_ring)->desc[index];
+			} else {
+				desc++;
+			}
+		} else {
+			break;
+		}
+	}
+	tx_ring->free_index = index;
+	tx_ring->num_used -= i;
+	eth_check_num_used(tx_ring);
+}
+
+static int eth_poll(struct napi_struct *napi, int budget)
+{
+	struct sw *sw = container_of(napi, struct sw, napi);
+	struct _rx_ring *rx_ring = &sw->rx_ring;
+	int received = 0;
+	unsigned int length;
+	unsigned int i = rx_ring->cur_index;
+	struct rx_desc *desc = &(rx_ring)->desc[i];
+	unsigned int alloc_count = rx_ring->alloc_count;
+
+	while (desc->cown && alloc_count + received < RX_DESCS - 1) {
+		struct sk_buff *skb;
+		int reserve = SKB_HEAD_ALIGN;
+
+		if (received >= budget)
+			break;
+
+		/* process received frame */
+		dma_unmap_single(sw->dev, rx_ring->phys_tab[i],
+				 RX_SEGMENT_MRU, DMA_FROM_DEVICE);
+
+		skb = build_skb(rx_ring->buff_tab[i], RX_SEGMENT_ALLOC_SIZE);
+		if (!skb)
+			break;
+
+		skb->dev = switch_port_tab[desc->sp]->netdev;
+
+		length = desc->sdl;
+		if (desc->fsd && !desc->lsd)
+			length = RX_SEGMENT_MRU;
+
+		if (!desc->fsd) {
+			reserve -= NET_IP_ALIGN;
+			if (!desc->lsd)
+				length += NET_IP_ALIGN;
+		}
+
+		skb_reserve(skb, reserve);
+		skb_put(skb, length);
+
+		if (!sw->frag_first)
+			sw->frag_first = skb;
+		else {
+			if (sw->frag_first == sw->frag_last)
+				skb_shinfo(sw->frag_first)->frag_list = skb;
+			else
+				sw->frag_last->next = skb;
+			sw->frag_first->len += skb->len;
+			sw->frag_first->data_len += skb->len;
+			sw->frag_first->truesize += skb->truesize;
+		}
+		sw->frag_last = skb;
+
+		if (desc->lsd) {
+			struct net_device *dev;
+
+			skb = sw->frag_first;
+			dev = skb->dev;
+			skb->protocol = eth_type_trans(skb, dev);
+
+			dev->stats.rx_packets++;
+			dev->stats.rx_bytes += skb->len;
+
+			/* RX Hardware checksum offload */
+			skb->ip_summed = CHECKSUM_NONE;
+			switch (desc->prot) {
+				case 1:
+				case 2:
+				case 5:
+				case 6:
+				case 13:
+				case 14:
+					if (!desc->l4f) {
+						skb->ip_summed = CHECKSUM_UNNECESSARY;
+						napi_gro_receive(napi, skb);
+						break;
+					}
+					/* fall through */
+				default:
+					netif_receive_skb(skb);
+					break;
+			}
+
+			sw->frag_first = NULL;
+			sw->frag_last = NULL;
+		}
+
+		received++;
+		if (++i == RX_DESCS) {
+			i = 0;
+			desc = &(rx_ring)->desc[i];
+		} else {
+			desc++;
+		}
+	}
+
+	rx_ring->cur_index = i;
+	if (!received) {
+		napi_complete(napi);
+		enable_irq(sw->rx_irq);
+		budget = 0;
+
+		/* If 1 or more frames came in during IRQ enable, re-schedule */
+		if (rx_ring->desc[i].cown)
+			eth_schedule_poll(sw);
+	}
+
+	spin_lock_bh(&tx_lock);
+	eth_complete_tx(sw);
+	spin_unlock_bh(&tx_lock);
+
+	cns3xxx_alloc_rx_buf(sw, received);
+
+	wmb();
+	enable_rx_dma(sw);
+
+	return budget;
+}
+
+static void eth_set_desc(struct sw *sw, struct _tx_ring *tx_ring, int index,
+			 int index_last, void *data, int len, u32 config0,
+			 u32 pmap)
+{
+	struct tx_desc *tx_desc = &(tx_ring)->desc[index];
+	unsigned int phys;
+
+	phys = dma_map_single(sw->dev, data, len, DMA_TO_DEVICE);
+	tx_desc->sdp = phys;
+	tx_desc->pmap = pmap;
+	tx_ring->phys_tab[index] = phys;
+
+	config0 |= len;
+	if (index == TX_DESCS - 1)
+		config0 |= END_OF_RING;
+	if (index == index_last)
+		config0 |= LAST_SEGMENT;
+
+	wmb();
+	tx_desc->config0 = config0;
+}
+
+static int eth_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	struct sw *sw = port->sw;
+	struct _tx_ring *tx_ring = &sw->tx_ring;
+	struct sk_buff *skb1;
+	char pmap = (1 << port->id);
+	int nr_frags = skb_shinfo(skb)->nr_frags;
+	int nr_desc = nr_frags;
+	int index0, index, index_last;
+	int len0;
+	unsigned int i;
+	u32 config0;
+
+	if (pmap == 8)
+		pmap = (1 << 4);
+
+	skb_walk_frags(skb, skb1)
+		nr_desc++;
+
+	eth_schedule_poll(sw);
+	spin_lock_bh(&tx_lock);
+	if ((tx_ring->num_used + nr_desc + 1) >= TX_DESCS) {
+		spin_unlock_bh(&tx_lock);
+		return NETDEV_TX_BUSY;
+	}
+
+	index = index0 = tx_ring->cur_index;
+	index_last = (index0 + nr_desc) % TX_DESCS;
+	tx_ring->cur_index = (index_last + 1) % TX_DESCS;
+
+	spin_unlock_bh(&tx_lock);
+
+	config0 = FORCE_ROUTE;
+	if (skb->ip_summed == CHECKSUM_PARTIAL)
+		config0 |= UDP_CHECKSUM | TCP_CHECKSUM;
+
+	len0 = skb->len;
+
+	/* fragments */
+	for (i = 0; i < nr_frags; i++) {
+		struct skb_frag_struct *frag;
+		void *addr;
+
+		index = (index + 1) % TX_DESCS;
+
+		frag = &skb_shinfo(skb)->frags[i];
+		addr = page_address(skb_frag_page(frag)) + frag->page_offset;
+
+		eth_set_desc(sw, tx_ring, index, index_last, addr, frag->size,
+			     config0, pmap);
+	}
+
+	if (nr_frags)
+		len0 = skb->len - skb->data_len;
+
+	skb_walk_frags(skb, skb1) {
+		index = (index + 1) % TX_DESCS;
+		len0 -= skb1->len;
+
+		eth_set_desc(sw, tx_ring, index, index_last, skb1->data,
+			     skb1->len, config0, pmap);
+	}
+
+	tx_ring->buff_tab[index0] = skb;
+	eth_set_desc(sw, tx_ring, index0, index_last, skb->data, len0,
+		     config0 | FIRST_SEGMENT, pmap);
+
+	wmb();
+
+	spin_lock(&tx_lock);
+	tx_ring->num_used += nr_desc + 1;
+	spin_unlock(&tx_lock);
+
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+
+	enable_tx_dma(sw);
+
+	return NETDEV_TX_OK;
+}
+
+static int eth_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+	struct port *port = netdev_priv(dev);
+
+	if (!netif_running(dev))
+		return -EINVAL;
+	return phy_mii_ioctl(port->phydev, req, cmd);
+}
+
+/* ethtool support */
+
+static void cns3xxx_get_drvinfo(struct net_device *dev,
+			       struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, DRV_NAME);
+	strcpy(info->bus_info, "internal");
+}
+
+static int cns3xxx_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct port *port = netdev_priv(dev);
+	return phy_ethtool_gset(port->phydev, cmd);
+}
+
+static int cns3xxx_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct port *port = netdev_priv(dev);
+	return phy_ethtool_sset(port->phydev, cmd);
+}
+
+static int cns3xxx_nway_reset(struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	return phy_start_aneg(port->phydev);
+}
+
+static struct ethtool_ops cns3xxx_ethtool_ops = {
+	.get_drvinfo = cns3xxx_get_drvinfo,
+	.get_settings = cns3xxx_get_settings,
+	.set_settings = cns3xxx_set_settings,
+	.nway_reset = cns3xxx_nway_reset,
+	.get_link = ethtool_op_get_link,
+};
+
+
+static int init_rings(struct sw *sw)
+{
+	int i;
+	struct _rx_ring *rx_ring = &sw->rx_ring;
+	struct _tx_ring *tx_ring = &sw->tx_ring;
+
+	__raw_writel(0, &sw->regs->fs_dma_ctrl0);
+	__raw_writel(TS_SUSPEND | FS_SUSPEND, &sw->regs->dma_auto_poll_cfg);
+	__raw_writel(QUEUE_THRESHOLD, &sw->regs->dma_ring_ctrl);
+	__raw_writel(CLR_FS_STATE | QUEUE_THRESHOLD, &sw->regs->dma_ring_ctrl);
+
+	__raw_writel(QUEUE_THRESHOLD, &sw->regs->dma_ring_ctrl);
+
+	rx_ring->desc = dmam_alloc_coherent(sw->dev, RX_POOL_ALLOC_SIZE,
+					    &rx_ring->phys_addr, GFP_KERNEL);
+	if (!rx_ring->desc)
+		return -ENOMEM;
+
+	/* Setup RX buffers */
+	memset(rx_ring->desc, 0, RX_POOL_ALLOC_SIZE);
+	for (i = 0; i < RX_DESCS; i++) {
+		struct rx_desc *desc = &(rx_ring)->desc[i];
+		void *buf;
+
+		buf = netdev_alloc_frag(RX_SEGMENT_ALLOC_SIZE);
+		if (!buf)
+			return -ENOMEM;
+
+		desc->sdl = RX_SEGMENT_MRU;
+		if (i == (RX_DESCS - 1))
+			desc->eor = 1;
+		desc->fsd = 1;
+		desc->lsd = 1;
+
+		desc->sdp = dma_map_single(sw->dev, buf + SKB_HEAD_ALIGN,
+					   RX_SEGMENT_MRU, DMA_FROM_DEVICE);
+		if (dma_mapping_error(sw->dev, desc->sdp))
+			return -EIO;
+
+		rx_ring->buff_tab[i] = buf;
+		rx_ring->phys_tab[i] = desc->sdp;
+		desc->cown = 0;
+	}
+	__raw_writel(rx_ring->phys_addr, &sw->regs->fs_desc_ptr0);
+	__raw_writel(rx_ring->phys_addr, &sw->regs->fs_desc_base_addr0);
+
+	tx_ring->desc = dmam_alloc_coherent(sw->dev, TX_POOL_ALLOC_SIZE,
+					    &tx_ring->phys_addr, GFP_KERNEL);
+	if (!tx_ring->desc)
+		return -ENOMEM;
+
+	/* Setup TX buffers */
+	memset(tx_ring->desc, 0, TX_POOL_ALLOC_SIZE);
+	for (i = 0; i < TX_DESCS; i++) {
+		struct tx_desc *desc = &(tx_ring)->desc[i];
+		tx_ring->buff_tab[i] = 0;
+
+		if (i == (TX_DESCS - 1))
+			desc->eor = 1;
+		desc->cown = 1;
+	}
+	__raw_writel(tx_ring->phys_addr, &sw->regs->ts_desc_ptr0);
+	__raw_writel(tx_ring->phys_addr, &sw->regs->ts_desc_base_addr0);
+
+	return 0;
+}
+
+static void destroy_rings(struct sw *sw)
+{
+	int i;
+
+	for (i = 0; i < RX_DESCS; i++) {
+		struct _rx_ring *rx_ring = &sw->rx_ring;
+		struct rx_desc *desc = &(rx_ring)->desc[i];
+		void *buf = sw->rx_ring.buff_tab[i];
+
+		if (!buf)
+			continue;
+
+		dma_unmap_single(sw->dev, desc->sdp, RX_SEGMENT_MRU,
+				 DMA_FROM_DEVICE);
+		skb_free_frag(buf);
+	}
+
+	for (i = 0; i < TX_DESCS; i++) {
+		struct _tx_ring *tx_ring = &sw->tx_ring;
+		struct tx_desc *desc = &(tx_ring)->desc[i];
+		struct sk_buff *skb = sw->tx_ring.buff_tab[i];
+
+		if (!skb)
+			continue;
+
+		dma_unmap_single(sw->dev, desc->sdp, skb->len, DMA_TO_DEVICE);
+		dev_kfree_skb(skb);
+	}
+}
+
+static int eth_open(struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	struct sw *sw = port->sw;
+	u32 temp;
+
+	port->speed = 0;	/* force "link up" message */
+	phy_start(port->phydev);
+
+	netif_start_queue(dev);
+
+	if (!ports_open) {
+		request_irq(sw->rx_irq, eth_rx_irq, IRQF_SHARED, "gig_switch", napi_dev);
+		request_irq(sw->stat_irq, eth_stat_irq, IRQF_SHARED, "gig_stat", napi_dev);
+		napi_enable(&sw->napi);
+		netif_start_queue(napi_dev);
+
+ 		__raw_writel(~(MAC0_STATUS_CHANGE | MAC1_STATUS_CHANGE | MAC2_STATUS_CHANGE |
+ 			       MAC0_RX_ERROR | MAC1_RX_ERROR | MAC2_RX_ERROR), &sw->regs->intr_mask);
+
+		temp = __raw_readl(&sw->regs->mac_cfg[2]);
+		temp &= ~(PORT_DISABLE);
+		__raw_writel(temp, &sw->regs->mac_cfg[2]);
+
+		temp = __raw_readl(&sw->regs->dma_auto_poll_cfg);
+		temp &= ~(TS_SUSPEND | FS_SUSPEND);
+		__raw_writel(temp, &sw->regs->dma_auto_poll_cfg);
+
+		enable_rx_dma(sw);
+	}
+	temp = __raw_readl(&sw->regs->mac_cfg[port->id]);
+	temp &= ~(PORT_DISABLE);
+	__raw_writel(temp, &sw->regs->mac_cfg[port->id]);
+
+	ports_open++;
+	netif_carrier_on(dev);
+
+	return 0;
+}
+
+static int eth_close(struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	struct sw *sw = port->sw;
+	u32 temp;
+
+	ports_open--;
+
+	temp = __raw_readl(&sw->regs->mac_cfg[port->id]);
+	temp |= (PORT_DISABLE);
+	__raw_writel(temp, &sw->regs->mac_cfg[port->id]);
+
+	netif_stop_queue(dev);
+
+	phy_stop(port->phydev);
+
+	if (!ports_open) {
+		disable_irq(sw->rx_irq);
+		free_irq(sw->rx_irq, napi_dev);
+		disable_irq(sw->stat_irq);
+		free_irq(sw->stat_irq, napi_dev);
+		napi_disable(&sw->napi);
+		netif_stop_queue(napi_dev);
+		temp = __raw_readl(&sw->regs->mac_cfg[2]);
+		temp |= (PORT_DISABLE);
+		__raw_writel(temp, &sw->regs->mac_cfg[2]);
+
+		__raw_writel(TS_SUSPEND | FS_SUSPEND,
+			     &sw->regs->dma_auto_poll_cfg);
+	}
+
+	netif_carrier_off(dev);
+	return 0;
+}
+
+static void eth_rx_mode(struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	struct sw *sw = port->sw;
+	u32 temp;
+
+	temp = __raw_readl(&sw->regs->mac_glob_cfg);
+
+	if (dev->flags & IFF_PROMISC) {
+		if (port->id == 3)
+			temp |= ((1 << 2) << PROMISC_OFFSET);
+		else
+			temp |= ((1 << port->id) << PROMISC_OFFSET);
+	} else {
+		if (port->id == 3)
+			temp &= ~((1 << 2) << PROMISC_OFFSET);
+		else
+			temp &= ~((1 << port->id) << PROMISC_OFFSET);
+	}
+	__raw_writel(temp, &sw->regs->mac_glob_cfg);
+}
+
+static int eth_set_mac(struct net_device *netdev, void *p)
+{
+	struct port *port = netdev_priv(netdev);
+	struct sw *sw = port->sw;
+	struct sockaddr *addr = p;
+	u32 cycles = 0;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	/* Invalidate old ARL Entry */
+	if (port->id == 3)
+		__raw_writel((port->id << 16) | (0x4 << 9), &sw->regs->arl_ctrl[0]);
+	else
+		__raw_writel(((port->id + 1) << 16) | (0x4 << 9), &sw->regs->arl_ctrl[0]);
+	__raw_writel( ((netdev->dev_addr[0] << 24) | (netdev->dev_addr[1] << 16) |
+			(netdev->dev_addr[2] << 8) | (netdev->dev_addr[3])),
+			&sw->regs->arl_ctrl[1]);
+
+	__raw_writel( ((netdev->dev_addr[4] << 24) | (netdev->dev_addr[5] << 16) |
+			(1 << 1)),
+			&sw->regs->arl_ctrl[2]);
+	__raw_writel((1 << 19), &sw->regs->arl_vlan_cmd);
+
+	while (((__raw_readl(&sw->regs->arl_vlan_cmd) & (1 << 21)) == 0)
+			&& cycles < 5000) {
+		udelay(1);
+		cycles++;
+	}
+
+	cycles = 0;
+	memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
+
+	if (port->id == 3)
+		__raw_writel((port->id << 16) | (0x4 << 9), &sw->regs->arl_ctrl[0]);
+	else
+		__raw_writel(((port->id + 1) << 16) | (0x4 << 9), &sw->regs->arl_ctrl[0]);
+	__raw_writel( ((addr->sa_data[0] << 24) | (addr->sa_data[1] << 16) |
+			(addr->sa_data[2] << 8) | (addr->sa_data[3])),
+			&sw->regs->arl_ctrl[1]);
+
+	__raw_writel( ((addr->sa_data[4] << 24) | (addr->sa_data[5] << 16) |
+			(7 << 4) | (1 << 1)), &sw->regs->arl_ctrl[2]);
+	__raw_writel((1 << 19), &sw->regs->arl_vlan_cmd);
+
+	while (((__raw_readl(&sw->regs->arl_vlan_cmd) & (1 << 21)) == 0)
+		&& cycles < 5000) {
+		udelay(1);
+		cycles++;
+	}
+	return 0;
+}
+
+static int cns3xxx_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (new_mtu > MAX_MTU)
+		return -EINVAL;
+
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+static const struct net_device_ops cns3xxx_netdev_ops = {
+	.ndo_open = eth_open,
+	.ndo_stop = eth_close,
+	.ndo_start_xmit = eth_xmit,
+	.ndo_set_rx_mode = eth_rx_mode,
+	.ndo_do_ioctl = eth_ioctl,
+	.ndo_change_mtu = cns3xxx_change_mtu,
+	.ndo_set_mac_address = eth_set_mac,
+	.ndo_validate_addr = eth_validate_addr,
+};
+
+static int eth_init_one(struct platform_device *pdev)
+{
+	int i;
+	struct port *port;
+	struct sw *sw;
+	struct net_device *dev;
+	struct cns3xxx_plat_info *plat = pdev->dev.platform_data;
+	char phy_id[MII_BUS_ID_SIZE + 3];
+	int err;
+	u32 temp;
+	struct resource *res;
+	void __iomem *regs;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	err = cns3xxx_mdio_register(regs);
+	if (err)
+		return err;
+
+	if (!(napi_dev = alloc_etherdev(sizeof(struct sw)))) {
+		err = -ENOMEM;
+		goto err_remove_mdio;
+	}
+
+	strcpy(napi_dev->name, "switch%d");
+	napi_dev->features = NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST;
+
+	SET_NETDEV_DEV(napi_dev, &pdev->dev);
+	sw = netdev_priv(napi_dev);
+	memset(sw, 0, sizeof(struct sw));
+	sw->regs = regs;
+	sw->dev = &pdev->dev;
+
+	sw->rx_irq = platform_get_irq_byname(pdev, "eth_rx");
+	sw->stat_irq = platform_get_irq_byname(pdev, "eth_stat");
+
+	temp = __raw_readl(&sw->regs->phy_auto_addr);
+	temp |= (3 << 30); /* maximum frame length: 9600 bytes */
+	__raw_writel(temp, &sw->regs->phy_auto_addr);
+
+	for (i = 0; i < 4; i++) {
+		temp = __raw_readl(&sw->regs->mac_cfg[i]);
+		temp |= (PORT_DISABLE);
+		__raw_writel(temp, &sw->regs->mac_cfg[i]);
+	}
+
+	temp = PORT_DISABLE;
+	__raw_writel(temp, &sw->regs->mac_cfg[2]);
+
+	temp = __raw_readl(&sw->regs->vlan_cfg);
+	temp |= NIC_MODE | VLAN_UNAWARE;
+	__raw_writel(temp, &sw->regs->vlan_cfg);
+
+	__raw_writel(UNKNOWN_VLAN_TO_CPU |
+		     CRC_STRIPPING, &sw->regs->mac_glob_cfg);
+
+	if ((err = init_rings(sw)) != 0) {
+		err = -ENOMEM;
+		goto err_free;
+	}
+	platform_set_drvdata(pdev, napi_dev);
+
+	netif_napi_add(napi_dev, &sw->napi, eth_poll, NAPI_WEIGHT);
+
+	for (i = 0; i < 3; i++) {
+		if (!(plat->ports & (1 << i))) {
+			continue;
+		}
+
+		if (!(dev = alloc_etherdev(sizeof(struct port)))) {
+			goto free_ports;
+		}
+
+		port = netdev_priv(dev);
+		port->netdev = dev;
+		if (i == 2)
+			port->id = 3;
+		else
+			port->id = i;
+		port->sw = sw;
+
+		temp = __raw_readl(&sw->regs->mac_cfg[port->id]);
+		temp |= (PORT_DISABLE | PORT_BLOCK_STATE | PORT_LEARN_DIS);
+		__raw_writel(temp, &sw->regs->mac_cfg[port->id]);
+
+		SET_NETDEV_DEV(dev, &pdev->dev);
+		dev->netdev_ops = &cns3xxx_netdev_ops;
+		dev->ethtool_ops = &cns3xxx_ethtool_ops;
+		dev->tx_queue_len = 1000;
+		dev->features = NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST;
+
+		switch_port_tab[port->id] = port;
+		memcpy(dev->dev_addr, &plat->hwaddr[i], ETH_ALEN);
+
+		snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, "0", plat->phy[i]);
+		port->phydev = phy_connect(dev, phy_id, &cns3xxx_adjust_link,
+			PHY_INTERFACE_MODE_RGMII);
+		if ((err = IS_ERR(port->phydev))) {
+			switch_port_tab[port->id] = 0;
+			free_netdev(dev);
+			goto free_ports;
+		}
+
+		port->phydev->irq = PHY_IGNORE_INTERRUPT;
+
+		if ((err = register_netdev(dev))) {
+			phy_disconnect(port->phydev);
+			switch_port_tab[port->id] = 0;
+			free_netdev(dev);
+			goto free_ports;
+		}
+
+		printk(KERN_INFO "%s: RGMII PHY %i on cns3xxx Switch\n", dev->name, plat->phy[i]);
+		netif_carrier_off(dev);
+		dev = 0;
+	}
+
+	return 0;
+
+free_ports:
+	err = -ENOMEM;
+	for (--i; i >= 0; i--) {
+		if (switch_port_tab[i]) {
+			port = switch_port_tab[i];
+			dev = port->netdev;
+			unregister_netdev(dev);
+			phy_disconnect(port->phydev);
+			switch_port_tab[i] = 0;
+			free_netdev(dev);
+		}
+	}
+err_free:
+	free_netdev(napi_dev);
+err_remove_mdio:
+	cns3xxx_mdio_remove();
+	return err;
+}
+
+static int eth_remove_one(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct sw *sw = netdev_priv(dev);
+	int i;
+
+	destroy_rings(sw);
+	for (i = 3; i >= 0; i--) {
+		if (switch_port_tab[i]) {
+			struct port *port = switch_port_tab[i];
+			struct net_device *dev = port->netdev;
+			unregister_netdev(dev);
+			phy_disconnect(port->phydev);
+			switch_port_tab[i] = 0;
+			free_netdev(dev);
+		}
+	}
+
+	free_netdev(napi_dev);
+	cns3xxx_mdio_remove();
+
+	return 0;
+}
+
+static struct platform_driver cns3xxx_eth_driver = {
+	.driver.name	= DRV_NAME,
+	.probe		= eth_init_one,
+	.remove		= eth_remove_one,
+};
+
+static int __init eth_init_module(void)
+{
+	return platform_driver_register(&cns3xxx_eth_driver);
+}
+
+static void __exit eth_cleanup_module(void)
+{
+	platform_driver_unregister(&cns3xxx_eth_driver);
+}
+
+module_init(eth_init_module);
+module_exit(eth_cleanup_module);
+
+MODULE_AUTHOR("Chris Lang");
+MODULE_DESCRIPTION("Cavium CNS3xxx Ethernet driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cns3xxx_eth");
diff --git a/drivers/spi/spi-cns3xxx.c b/drivers/spi/spi-cns3xxx.c
new file mode 100644
index 00000000..63019862
--- /dev/null
+++ b/drivers/spi/spi-cns3xxx.c
@@ -0,0 +1,448 @@
+/*******************************************************************************
+ *
+ *  CNS3XXX SPI controller driver (master mode only)
+ *
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright 2011 Gateworks Corporation
+ *		   Chris Lang <clang@gateworks.com>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  This file is distributed in the hope that it will be useful,
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this file; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or
+ *  visit http://www.gnu.org/licenses/.
+ *
+ *  This file may also be available under a different license from Cavium.
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/mtd/partitions.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+
+#include <asm/io.h>
+#include <asm/memory.h>
+#include <asm/dma.h>
+#include <asm/delay.h>
+#include <linux/module.h>
+
+/*
+ * define access macros
+ */
+#define SPI_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(hw->base + reg_offset)))
+
+#define SPI_CONFIGURATION_REG			SPI_MEM_MAP_VALUE(0x00)
+#define SPI_SERVICE_STATUS_REG			SPI_MEM_MAP_VALUE(0x04)
+#define SPI_BIT_RATE_CONTROL_REG		SPI_MEM_MAP_VALUE(0x08)
+#define SPI_TRANSMIT_CONTROL_REG		SPI_MEM_MAP_VALUE(0x0C)
+#define SPI_TRANSMIT_BUFFER_REG			SPI_MEM_MAP_VALUE(0x10)
+#define SPI_RECEIVE_CONTROL_REG			SPI_MEM_MAP_VALUE(0x14)
+#define SPI_RECEIVE_BUFFER_REG			SPI_MEM_MAP_VALUE(0x18)
+#define SPI_FIFO_TRANSMIT_CONFIG_REG		SPI_MEM_MAP_VALUE(0x1C)
+#define SPI_FIFO_TRANSMIT_CONTROL_REG		SPI_MEM_MAP_VALUE(0x20)
+#define SPI_FIFO_RECEIVE_CONFIG_REG		SPI_MEM_MAP_VALUE(0x24)
+#define SPI_INTERRUPT_STATUS_REG		SPI_MEM_MAP_VALUE(0x28)
+#define SPI_INTERRUPT_ENABLE_REG		SPI_MEM_MAP_VALUE(0x2C)
+
+#define SPI_TRANSMIT_BUFFER_REG_ADDR		(CNS3XXX_SSP_BASE +0x10)
+#define SPI_RECEIVE_BUFFER_REG_ADDR		(CNS3XXX_SSP_BASE +0x18)
+
+/* Structure for SPI controller of CNS3XXX SOCs */
+struct cns3xxx_spi {
+	/* bitbang has to be first */
+	struct spi_bitbang bitbang;
+	struct completion done;
+	wait_queue_head_t wait;
+
+	int len;
+	int count;
+	int last_in_message_list;
+
+	/* data buffers */
+	const unsigned char *tx;
+	unsigned char *rx;
+
+	void __iomem *base;
+	struct spi_master *master;
+	struct platform_device *pdev;
+	struct device *dev;
+};
+
+static inline u8 cns3xxx_spi_bus_idle(struct cns3xxx_spi *hw)
+{
+	return ((SPI_SERVICE_STATUS_REG & 0x1) ? 0 : 1);
+}
+
+static inline u8 cns3xxx_spi_tx_buffer_empty(struct cns3xxx_spi *hw)
+{
+	return ((SPI_INTERRUPT_STATUS_REG & (0x1 << 3)) ? 1 : 0);
+}
+
+static inline u8 cns3xxx_spi_rx_buffer_full(struct cns3xxx_spi *hw)
+{
+	return ((SPI_INTERRUPT_STATUS_REG & (0x1 << 2)) ? 1 : 0);
+}
+
+u8 cns3xxx_spi_tx_rx(struct cns3xxx_spi *hw, u8 tx_channel, u8 tx_eof,
+		     u32 tx_data, u32 * rx_data)
+{
+	u8 rx_channel;
+	u8 rx_eof;
+
+	while (!cns3xxx_spi_bus_idle(hw)) ;	// do nothing
+
+	while (!cns3xxx_spi_tx_buffer_empty(hw)) ;	// do nothing
+
+	SPI_TRANSMIT_CONTROL_REG &= ~(0x7);
+	SPI_TRANSMIT_CONTROL_REG |= (tx_channel & 0x3) | ((tx_eof & 0x1) << 2);
+
+	SPI_TRANSMIT_BUFFER_REG = tx_data;
+
+	while (!cns3xxx_spi_rx_buffer_full(hw)) ;	// do nothing
+
+	rx_channel = SPI_RECEIVE_CONTROL_REG & 0x3;
+	rx_eof = (SPI_RECEIVE_CONTROL_REG & (0x1 << 2)) ? 1 : 0;
+
+	*rx_data = SPI_RECEIVE_BUFFER_REG;
+
+	if ((tx_channel != rx_channel) || (tx_eof != rx_eof)) {
+		return 0;
+	} else {
+		return 1;
+	}
+}
+
+u8 cns3xxx_spi_tx(struct cns3xxx_spi *hw, u8 tx_channel, u8 tx_eof, u32 tx_data)
+{
+
+        while (!cns3xxx_spi_bus_idle(hw)) ;       // do nothing
+
+        while (!cns3xxx_spi_tx_buffer_empty(hw)) ;        // do nothing
+
+        SPI_TRANSMIT_CONTROL_REG &= ~(0x7);
+        SPI_TRANSMIT_CONTROL_REG |= (tx_channel & 0x3) | ((tx_eof & 0x1) << 2);
+
+        SPI_TRANSMIT_BUFFER_REG = tx_data;
+
+        return 1;
+}
+
+static inline struct cns3xxx_spi *to_hw(struct spi_device *sdev)
+{
+	return spi_master_get_devdata(sdev->master);
+}
+
+static int cns3xxx_spi_setup_transfer(struct spi_device *spi,
+				      struct spi_transfer *t)
+{
+	return 0;
+}
+
+static void cns3xxx_spi_chipselect(struct spi_device *spi, int value)
+{
+	struct cns3xxx_spi *hw = to_hw(spi);
+	unsigned int spi_config;
+
+	switch (value) {
+	case BITBANG_CS_INACTIVE:
+		break;
+
+	case BITBANG_CS_ACTIVE:
+		spi_config = SPI_CONFIGURATION_REG;
+
+		if (spi->mode & SPI_CPHA)
+			spi_config |= (0x1 << 13);
+		else
+			spi_config &= ~(0x1 << 13);
+
+		if (spi->mode & SPI_CPOL)
+			spi_config |= (0x1 << 14);
+		else
+			spi_config &= ~(0x1 << 14);
+
+		/* write new configration */
+		SPI_CONFIGURATION_REG = spi_config;
+
+		SPI_TRANSMIT_CONTROL_REG &= ~(0x7);
+		SPI_TRANSMIT_CONTROL_REG |= (spi->chip_select & 0x3);
+
+		break;
+	}
+}
+
+static int cns3xxx_spi_setup(struct spi_device *spi)
+{
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	return 0;
+}
+
+static int cns3xxx_spi_txrx(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct cns3xxx_spi *hw = to_hw(spi);
+
+	dev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n", t->tx_buf, t->rx_buf,
+		t->len);
+
+	hw->tx = t->tx_buf;
+	hw->rx = t->rx_buf;
+	hw->len = t->len;
+	hw->count = 0;
+	hw->last_in_message_list = t->last_in_message_list;
+
+	init_completion(&hw->done);
+
+	if (hw->tx) {
+		int i;
+		u32 rx_data;
+		for (i = 0; i < (hw->len - 1); i++) {
+			dev_dbg(&spi->dev,
+				"[SPI_CNS3XXX_DEBUG] hw->tx[%02d]: 0x%02x\n", i,
+				hw->tx[i]);
+			cns3xxx_spi_tx_rx(hw, spi->chip_select, 0, hw->tx[i],
+					  &rx_data);
+			if (hw->rx) {
+				hw->rx[i] = rx_data;
+				dev_dbg(&spi->dev,
+					"[SPI_CNS3XXX_DEBUG] hw->rx[%02d]: 0x%02x\n",
+					i, hw->rx[i]);
+			}
+		}
+
+		if (t->last_in_message_list) {
+			cns3xxx_spi_tx_rx(hw, spi->chip_select, 1, hw->tx[i],
+					  &rx_data);
+			if (hw->rx) {
+				hw->rx[i] = rx_data;
+				dev_dbg(&spi->dev,
+					"[SPI_CNS3XXX_DEBUG] hw->rx[%02d]: 0x%02x\n",
+					i, hw->rx[i]);
+			}
+		} else {
+			cns3xxx_spi_tx_rx(hw, spi->chip_select, 0, hw->tx[i],
+					  &rx_data);
+		}
+		goto done;
+	}
+
+	if (hw->rx) {
+		int i;
+		u32 rx_data;
+		for (i = 0; i < (hw->len - 1); i++) {
+			cns3xxx_spi_tx_rx(hw, spi->chip_select, 0, 0xff, &rx_data);
+			hw->rx[i] = rx_data;
+			dev_dbg(&spi->dev,
+				"[SPI_CNS3XXX_DEBUG] hw->rx[%02d]: 0x%02x\n", i,
+				hw->rx[i]);
+		}
+
+		if (t->last_in_message_list) {
+			cns3xxx_spi_tx_rx(hw, spi->chip_select, 1, 0xff, &rx_data);
+		} else {
+			cns3xxx_spi_tx_rx(hw, spi->chip_select, 0, 0xff, &rx_data);
+		}
+		hw->rx[i] = rx_data;
+		dev_dbg(&spi->dev, "[SPI_CNS3XXX_DEBUG] hw->rx[%02d]: 0x%02x\n",
+			i, hw->rx[i]);
+	}
+done:
+	return hw->len;
+}
+
+static void __init cns3xxx_spi_initial(struct cns3xxx_spi *hw)
+{
+	SPI_CONFIGURATION_REG = (((0x0 & 0x3) << 0) |	/* 8bits shift length */
+				 (0x0 << 9) |	/* SPI mode */
+				 (0x0 << 10) |	/* disable FIFO */
+				 (0x1 << 11) |	/* SPI master mode */
+				 (0x0 << 12) |	/* disable SPI loopback mode */
+				 (0x1 << 13) |	/* clock phase */
+				 (0x1 << 14) |	/* clock polarity */
+				 (0x0 << 24) |	/* disable - SPI data swap */
+				 (0x1 << 29) |	/* enable - 2IO Read mode */
+				 (0x0 << 30) |	/* disable - SPI high speed read for system boot up */
+				 (0x0 << 31));	/* disable - SPI */
+
+	/* Set SPI bit rate PCLK/2 */
+	SPI_BIT_RATE_CONTROL_REG = 0x1;
+
+	/* Set SPI Tx channel 0 */
+	SPI_TRANSMIT_CONTROL_REG = 0x0;
+
+	/* Set Tx FIFO Threshold, Tx FIFO has 2 words */
+	SPI_FIFO_TRANSMIT_CONFIG_REG &= ~(0x03 << 4);
+	SPI_FIFO_TRANSMIT_CONFIG_REG |= ((0x0 & 0x03) << 4);
+
+	/* Set Rx FIFO Threshold, Rx FIFO has 2 words */
+	SPI_FIFO_RECEIVE_CONFIG_REG &= ~(0x03 << 4);
+	SPI_FIFO_RECEIVE_CONFIG_REG |= ((0x0 & 0x03) << 4);
+
+	/* Disable all interrupt */
+	SPI_INTERRUPT_ENABLE_REG = 0x0;
+
+	/* Clear spurious interrupt sources */
+	SPI_INTERRUPT_STATUS_REG = (0x0F << 4);
+
+	/* Enable SPI */
+	SPI_CONFIGURATION_REG |= (0x1 << 31);
+
+	return;
+}
+
+static int cns3xxx_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct cns3xxx_spi *hw;
+	struct resource *res;
+	int err = 0;
+
+	printk("%s: setup CNS3XXX SPI Controller\n", __FUNCTION__);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	/* Allocate master with space for cns3xxx_spi */
+	master = spi_alloc_master(&pdev->dev, sizeof(struct cns3xxx_spi));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "No memory for spi_master\n");
+		err = -ENOMEM;
+		goto err_nomem;
+	}
+
+	hw = spi_master_get_devdata(master);
+	memset(hw, 0, sizeof(struct cns3xxx_spi));
+
+	hw->master = spi_master_get(master);
+	hw->dev = &pdev->dev;
+
+	hw->base = devm_ioremap_resource(hw->dev, res);
+	if (IS_ERR(hw->base)) {
+		dev_err(hw->dev, "Unable to map registers\n");
+		err = PTR_ERR(hw->base);
+		goto err_register;
+	}
+
+	platform_set_drvdata(pdev, hw);
+	init_completion(&hw->done);
+
+	/* setup the master state. */
+
+	master->num_chipselect = 4;
+	master->bus_num = 1;
+
+	/* setup the state for the bitbang driver */
+
+	hw->bitbang.master = hw->master;
+	hw->bitbang.setup_transfer = cns3xxx_spi_setup_transfer;
+	hw->bitbang.chipselect = cns3xxx_spi_chipselect;
+	hw->bitbang.txrx_bufs = cns3xxx_spi_txrx;
+	hw->bitbang.master->setup = cns3xxx_spi_setup;
+
+	dev_dbg(hw->dev, "bitbang at %p\n", &hw->bitbang);
+
+	/* SPI controller initializations */
+	cns3xxx_spi_initial(hw);
+
+	/* register SPI controller */
+
+	err = spi_bitbang_start(&hw->bitbang);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to register SPI master\n");
+		goto err_register;
+	}
+
+	return 0;
+
+err_register:
+	spi_master_put(hw->master);;
+
+err_nomem:
+	return err;
+}
+
+static int cns3xxx_spi_remove(struct platform_device *dev)
+{
+	struct cns3xxx_spi *hw = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+
+	spi_unregister_master(hw->master);
+
+	spi_master_put(hw->master);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int cns3xxx_spi_suspend(struct platform_device *pdev, pm_message_t msg)
+{
+	struct cns3xxx_spi *hw = platform_get_drvdata(pdev);
+
+	return 0;
+}
+
+static int cns3xxx_spi_resume(struct platform_device *pdev)
+{
+	struct cns3xxx_spi *hw = platform_get_drvdata(pdev);
+
+	return 0;
+}
+
+#else
+#define cns3xxx_spi_suspend	NULL
+#define cns3xxx_spi_resume	NULL
+#endif
+
+static struct platform_driver cns3xxx_spi_driver = {
+	.probe		= cns3xxx_spi_probe,
+	.remove		= cns3xxx_spi_remove,
+	.suspend	= cns3xxx_spi_suspend,
+	.resume		= cns3xxx_spi_resume,
+	.driver		= {
+		.name = "cns3xxx_spi",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init cns3xxx_spi_init(void)
+{
+	return platform_driver_register(&cns3xxx_spi_driver);
+}
+
+static void __exit cns3xxx_spi_exit(void)
+{
+	platform_driver_unregister(&cns3xxx_spi_driver);
+}
+
+module_init(cns3xxx_spi_init);
+module_exit(cns3xxx_spi_exit);
+
+MODULE_AUTHOR("Cavium Networks");
+MODULE_DESCRIPTION("CNS3XXX SPI Controller Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cns3xxx_spi");
+
+EXPORT_SYMBOL_GPL(cns3xxx_spi_tx_rx);
diff --git a/include/linux/platform_data/cns3xxx.h b/include/linux/platform_data/cns3xxx.h
new file mode 100644
index 00000000..f286d0df
--- /dev/null
+++ b/include/linux/platform_data/cns3xxx.h
@@ -0,0 +1,26 @@
+/*
+ * arch/arm/mach-cns3xxx/include/mach/platform.h
+ *
+ * Copyright 2011 Gateworks Corporation
+ *		  Chris Lang <clang@gateworks.com
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_ARCH_PLATFORM_H
+#define __ASM_ARCH_PLATFORM_H
+
+#ifndef __ASSEMBLY__
+
+/* Information about built-in Ethernet MAC interfaces */
+struct cns3xxx_plat_info {
+	u8 ports; /* Bitmap of enabled Ports */
+	u8 hwaddr[4][6];
+	u32 phy[3];
+};
+
+#endif /* __ASM_ARCH_PLATFORM_H */
+#endif
-- 
2.11.0

